1. Массивы
2. Связные списки
3. Двусвязные списки
4. Кольцевые списки
5. Стэки
6. Очереди
7. Деки (двусторонние очереди)
8. Динамические массивы
9. Хэш-таблицы
10. Хэш-функции
11. Открытая адресация в хэш-таблицах
12. Цепочечное хэширование
13. Двоичные деревья
14. Двоичные деревья поиска
15. Самобалансирующиеся деревья
16. AVL-деревья
17. Красно-черные деревья
18. B-деревья
19. B+-деревья
20. Splay-деревья
21. Трие (префиксные деревья)
22. Суффиксные деревья
23. Суффиксные массивы
24. Кучи
25. Бинарные кучи
26. Фибоначчиева куча
27. Приоритетные очереди
28. Деревья отрезков
29. Деревья Фенвика (бинарные индексные деревья)
30. Множества с непересекающимися подмножествами (Union-Find)
31. Скип-листы
32. Деревья диапазонов
33. Интервальные деревья
34. К-мерные деревья (k-d tree)
35. Квадродеревья
36. Октадеревья
37. Декартовы деревья (treap)
38. Роупы (Rope)
39. Блум-фильтры
40. Графы
41. Матрицы смежности
42. Списки смежности
43. Алгоритмы обхода графов (DFS, BFS)
44. Хеширование с открытой адресацией
45. Хеширование с цепочками
46. Динамические хеш-таблицы
47. Куку-хеширование
48. Множества и мультимножества
49. Отображения и мультимапы
50. Битовые векторы (битовые массивы)
51. Деревья суффиксных ссылок
52. Деревья ван Эмде Боаса
53. Буферные деревья (Buffer trees)
54. Деревья отрезков с ленивым обновлением
55. Модифицированные деревья отрезков
56. Деревья интервальных максимумов
57. Деревья интервалов отрезков
58. Деревья поиска с поддеревьями
59. Деревья порядковых статистик
60. Весовые балансирующие деревья
61. Имерсивные деревья
62. Функциональные (персистентные) структуры данных
63. Непрерывные структуры данных
64. Иммутабельные структуры данных
65. Конкурентные (параллельные) структуры данных
66. Безблокирующие (lock-free) структуры данных
67. Беспредельные (wait-free) структуры данных
68. Деревья с пространственным индексированием
69. R-деревья
70. R*-деревья
71. X-деревья
72. M-деревья
73. Индексные структуры для БД
74. Индексы на основе хешей
75. Файлы с индексом по B-дереву
76. Копьемные деревья (Spears)
77. Деревья каверны
78. Деревья периодов
79. Гиперкубы
80. Распределенные хеш-таблицы (DHT)
81. Таблицы консистентного хеширования
82. Skip-графы
83. Конденсированные три
84. Существенные трии
85. Деревья жирных ссылок
86. Суффиксные автоматные деревья
87. Палиндромические деревья (Эертри)
88. Динамические деревья
89. Link-Cut деревья
90. Euler Tour деревья
91. Деревья тяжёлого пути (HLD)
92. Центроидная декомпозиция
93. Комбинированные структуры данных
94. Сжатые структуры данных
95. Волновые деревья (Wavelet trees)
96. Сукцинктные (лаконичные) структуры данных
97. Структуры рангов и выборки
98. Двойные хеш-таблицы
99. Левосторонние кучи
100. Парные кучи
101. Троичные кучи
102. Дек с максимальным приоритетом
103. Имунные структуры данных
104. Линейные простые цепи
105. Spaghetti Stack
106. Монтажные списки
107. Расширяемые массивы
108. Circular Buffers (кольцевые буферы)
109. Комбинированные хеш-функции
110. Алгоритмы хеширования строк
111. Rolling Hash
112. Мини-хеши
113. Древовидные коды
114. Деревья решений
115. Кучи приоритетов
116. Главные файлы
117. Кучи для внешней памяти
118. Деревья буферов
119. Деревья биференцирования
120. Гиперсети
121. Матричные деревья
122. Структуры данных для быстрого поиска
123. Пространственные деревья
124. Хэш-кучи
125. Модифицированные хэш-таблицы
126. Квотные фильтры (Quotient Filters)
127. Гиперлог-лог
128. Вариативные структуры данных
129. Структуры данных с подвижными элементами
130. Оценочные структуры данных
131. Адаптивные структуры данных
132. Структуры данных с самокоррекцией
133. Панкучные деревья
134. Большие кучи
135. Глубокие деревья
136. Равновесные деревья
137. Структуры данных со случайизацией
138. Self-adjusting деревья
139. Квантильные деревья
140. Структуры данных для массивов
141. Многомерные деревья
142. Фрактальные деревья
143. LSM-деревья
144. Сборки таблиц
145. Деревья конфликта
146. Сословные деревья
147. Деревья Евклида
148. Бинарные решающие диаграммы
149. Деревья префиксов
150. Деревья паттернов
151. Аффинные деревья
152. Деревья суффиксов
153. Деревья Гомера
154. Деревья настроения
155. Стеки вызовов
156. Иерархические деревья
157. Гамма-коды
158. Деревья регистров
159. Деревья доступа
160. Деревья индексации
161. Фильтры клеток
162. Деревья бит
163. Деревья вероятности
164. Гистограммы
165. Алгоритмы поиска ближайшего соседа
166. Деревья разности
167. Деревья суммы
168. D-деревья
169. Y-деревья
170. H-деревья
171. G-деревья
172. Z-деревья
173. W-деревья
174. Динамические массивы
175. Таблицы разреженности
176. Деревья частот
177. Дисциплины памяти
178. Очереди с приоритетами
179. Кучи биномные
180. Кучи дноуправляемые
181. Адресные дерева
182. Ассоциативные массивы
183. Пространственные индексы
184. Инвертированные индексы
185. Построение индексов
186. Списки свободных блоков
187. Аренные аллокаторы
188. Стековые аллокаторы
189. Оконные буферы
190. LRU-кэши
191. Графовые базы данных
192. Хранение больших графов
193. Алгоритмы обработки графов
194. Алгоритмы планаризации графов
195. Алгоритмы разрезов
196. Деревья доминаторов
197. Сетевая маршрутизация
198. Поиск в глубину с отсечением
199. Поиск в ширину с ограничением
200. А* алгоритм
201. Бесконечные структуры данных
202. Структуры данных для потоков
203. Очереди сообщений
204. Транзакционные структуры данных
205. Локальные структуры данных
206. Распределенные структуры данных
207. Облачные структуры данных
208. Кэширование данных
209. Полнотекстовые индексы
210. BM-деревья
211. Многомерные хеш-таблицы
212. Персистентные структуры данных
213. Зипперы
214. Линейные хеш-таблицы
215. Расширяемые хеш-таблицы
216. Кэши прямого отображения
217. Директ-мэппинг
218. Set-associative кэши
219. Полностью ассоциативные кэши
220. Таблицы страниц
221. Инвертированные таблицы страниц
222. Буфер переходов страниц (TLB)
223. Ассоциативные кэши
224. Структуры данных для виртуальной памяти
225. Структуры данных для файловых систем
226. B*-деревья
227. H-деревья
228. Цифровые индексы
229. Критбитные деревья
230. Обходы графов с запоминанием
231. Структуры данных для машинного обучения
232. Деревья решений
233. Random Forest
234. Градиентный бустинг
235. KNN-структуры
236. Структуры для SVM
237. Хеширование чувствительное к locality
238. Алгоритмы кластеризации
239. K-средних
240. Алгоритмы ассоциации
241. Частотные наборы
242. FP-деревья
243. Структуры данных для NLP
244. N-граммы
245. Марковские цепи
246. Деревья зависимостей
247. Структуры данных для изображений
248. Кантрианская система
249. С графами
250. Метрики сходства
251. Алгоритмы рекомендаций
252. Структуры данных для IR
253. Обфускация данных
254. Структуры данных для криптографии
255. Алгоритмы шифрования
256. Деревья Меркла
257. Блокчейн структуры
258. Хэш-графы
259. Алгоритмы консенсуса
260. Трансформационные структуры данных
261. Реляционные модели
262. Нереляционные модели
263. Гибридные модели
264. Структуры данных для аудио
265. Волновые пакеты
266. Сплайн-интерполяция
267. Индексирование временных рядов
268. R-деревья с временными метками
269. Структуры данных для геоданных
270. Пространственные индексы
271. Геохеширование
272. Структуры данных для IoT
273. Потоковые структуры данных
274. Временные структуры данных
275. Алгоритмы сжатия данных
276. Алгоритмы кодирования
277. Алгоритмы декодирования
278. Сжатие без потерь
279. Сжатие с потерями
280. Параллельные структуры данных
281. Распределенные структуры данных
282. Базы знаний
283. Онтологии
284. Семантические сети
285. Деревья аргументации
286. Дискуссионные деревья
287. Коллаборативные фильтры
288. Структуры данных для социальных сетей
289. Графы дружбы
290. Взвешенные графы
291. Модели масштабируемости
292. Журналы транзакций
293. Снапшоты
294. Кольцевые буферы
295. Конвейеры данных
296. Event Sourcing
297. Архитектуры CQRS
298. Очереди заданий
299. Планировщики задач
300. Кэширование обратного вызова


========================================================================================================================================================================================================


1\. **Тема: Массивы**

**Вопрос:**

В языке программирования C, что из перечисленного верно для многомерных массивов?

A) Они хранятся в памяти по столбцам (column-major order).

B) При передаче двумерного массива в функцию нужно указать размеры всех измерений.

C) Многомерные массивы в C — это массивы массивов.

D) Индексы в многомерных массивах C начинаются с 1.

**Ответ:** C

---

2\. **Тема: Связные списки**

**Вопрос:**

Какова временная сложность доступа к элементу с номером *k* в односвязном списке из *n* элементов?

A) O(1)

B) O(log n)

C) O(k)

D) O(n)

**Ответ:** C

---

3\. **Тема: Двусвязные списки**

**Вопрос:**

Какое преимущество двусвязного списка перед односвязным при удалении узла, на который есть прямой указатель?

A) Удаление требует меньше памяти.

B) Не нужно искать предыдущий элемент для удаления.

C) Нельзя удалить узел без доступа к голове списка.

D) Двусвязные списки занимают меньше памяти из-за дополнительного указателя.

**Ответ:** B

---

4\. **Тема: Кольцевые списки**

**Вопрос:**

Какое утверждение о односвязных кольцевых списках верно?

A) В последнем узле указатель на следующий элемент равен NULL.

B) Можно найти конец списка по указателю NULL.

C) Кольцевой список позволяет обходить элементы по кругу без возвращения в начало.

D) Кольцевые списки не могут содержать более трёх элементов.

**Ответ:** C

---

5\. **Тема: Стэки**

**Вопрос:**

В языках без автоматического управления памятью, какая реализация стека позволяет обнаружить его переполнение?

A) Использование массива фиксированного размера.

B) Использование связного списка с динамическим размером.

C) Использование кольцевого буфера.

D) В таких языках переполнение стека невозможно.

**Ответ:** A

---

6\. **Тема: Очереди**

**Вопрос:**

Если реализовать очередь с помощью двух стеков, какая операция будет иметь амортизированную сложность O(1)?

A) Добавление элемента в очередь (enqueue).

B) Удаление элемента из очереди (dequeue).

C) Просмотр первого элемента без удаления (peek).

D) Очистка очереди.

**Ответ:** B

---

7\. **Тема: Деки (двусторонние очереди)**

**Вопрос:**

Какой алгоритм эффективно использует дек для хранения данных?

A) Алгоритм Дейкстры для кратчайшего пути.

B) Алгоритм нахождения минимума в скользящем окне.

C) Алгоритм быстрой сортировки.

D) Алгоритм сортировки слиянием.

**Ответ:** B

---

8\. **Тема: Динамические массивы**

**Вопрос:**

Что позволяет динамическому массиву обеспечивать амортизированное время O(1) на добавление элемента?

A) Предварительное выделение большого объёма памяти.

B) Увеличение размера на фиксированное число при переполнении.

C) Удвоение размера массива при переполнении.

D) Использование связного списка вместо массива.

**Ответ:** C

---

9\. **Тема: Хэш-таблицы**

**Вопрос:**

Какой метод разрешения коллизий в хеш-таблицах может привести к вторичной кластеризации?

A) Использование цепочек.

B) Линейное пробирование.

C) Двойное хеширование.

D) Кукушечное хеширование.

**Ответ:** B

---

10\. **Тема: Хэш-функции**

**Вопрос:**

Какое свойство хеш-функции важно для равномерного распределения ключей в хеш-таблице?

A) Детерминированность.

B) Быстрота вычисления.

C) Полное отсутствие коллизий.

D) Сильный эффект лавины (аваланш-эффект).

**Ответ:** D


========================================================================================================================================================================================================


1. **Тема:** Открытая адресация в хеш-таблицах

**Вопрос:** В хеш-таблице с открытой адресацией используется квадратичное пробирование для разрешения коллизий. Каков максимальный коэффициент заполнения таблицы (в процентах от её размера), при котором можно гарантировать вставку нового элемента в пустую таблицу?

A) 50%  
B) 70%  
C) 80%  
D) 100%  

**Правильный ответ:** A) 50%

---

2. **Тема:** Цепочечное хеширование

**Вопрос:** В хеш-таблице с цепочками для разрешения коллизий связные списки в бакетах можно заменить на какую структуру данных, чтобы улучшить худшее время поиска?

A) Двоичное дерево поиска  
B) Стек  
C) Очередь  
D) Куча  

**Правильный ответ:** A) Двоичное дерево поиска

---

3. **Тема:** Двоичные деревья

**Вопрос:** Сколько различных структур двоичных деревьев можно построить из N узлов?

A) N!  
B) Число Каталана для N  
C) 2^N  
D) N^N  

**Правильный ответ:** B) Число Каталана для N

---

4. **Тема:** Двоичные деревья поиска

**Вопрос:** Какова ожидаемая высота несбалансированного двоичного дерева поиска при вставке случайно упорядоченных уникальных ключей?

A) O(1)  
B) O(log N)  
C) O(√N)  
D) O(N)  

**Правильный ответ:** B) O(log N)

---

5. **Тема:** Самобалансирующиеся деревья

**Вопрос:** Какое из следующих самобалансирующихся деревьев гарантирует высоту O(log N) и минимизирует количество перестроек при вставке и удалении?

A) AVL-дерево  
B) Красно-черное дерево  
C) Splay-дерево  
D) Декартово дерево  

**Правильный ответ:** B) Красно-черное дерево

---

6. **Тема:** AVL-деревья

**Вопрос:** При удалении узла из AVL-дерева какое максимальное количество поворотов может потребоваться для восстановления баланса?

A) O(1)  
B) O(log N)  
C) O(N)  
D) O(N log N)  

**Правильный ответ:** B) O(log N)

---

7. **Тема:** Красно-черные деревья

**Вопрос:** Насколько длина самого длинного пути от корня к листу в красно-черном дереве может превышать длину самого короткого пути?

A) Не более чем в 2 раза  
B) Не более чем в 3 раза  
C) Не более чем в логарифмическое число раз  
D) Неограниченно  

**Правильный ответ:** A) Не более чем в 2 раза

---

8. **Тема:** B-деревья

**Вопрос:** Какое основное преимущество использования B-деревьев при работе с данными на диске?

A) Снижает использование оперативной памяти  
B) Сокращает число дисковых операций ввода-вывода  
C) Ускоряет обработку данных процессором  
D) Повышает эффективность кэширования в памяти  

**Правильный ответ:** B) Сокращает число дисковых операций ввода-вывода

---

9. **Тема:** B+-деревья

**Вопрос:** Чем отличаются листовые узлы в B+-дереве от обычного B-дерева, и как это влияет на скорость диапазонных запросов?

A) Листовые узлы связаны между собой, ускоряя диапазонные запросы  
B) Листовые узлы содержат ссылки на родителей  
C) Листовые узлы не хранят ключи, только данные  
D) Листовые узлы организованы в виде кучи  

**Правильный ответ:** A) Листовые узлы связаны между собой, ускоряя диапазонные запросы

---

10. **Тема:** Splay-деревья

**Вопрос:** Какой метод анализа используется, чтобы показать, что среднее время операции в splay-дереве составляет O(log N), несмотря на возможное худшее время O(N)?

A) Амортизационный анализ  
B) Метод потенциальных функций  
C) Анализ среднего случая  
D) Вероятностный анализ  

**Правильный ответ:** B) Метод потенциальных функций


========================================================================================================================================================================================================


---

**Вопрос 1 (Тема 21: Префиксные деревья (Tries))**

Какой тип trie наиболее эффективно экономит память при хранении множества строк с общими суффиксами за счёт объединения повторяющихся суффиксов?

a) Radix Tree

b) Сжатое trie

c) Суффиксное trie

d) DAWG

---

**Вопрос 2 (Тема 22: Суффиксные деревья)**

Какова временная сложность построения суффиксного дерева для строки длины *n* с использованием алгоритма Укконена?

a) O(*n* log *n*)

b) O(*n*²)

c) O(*n*)

d) O(log *n*)

---

**Вопрос 3 (Тема 23: Суффиксные массивы)**

Какой алгоритм позволяет построить суффиксный массив за линейное время?

a) Алгоритм Касаи

b) Алгоритм SA-IS

c) Алгоритм Беркли

d) Алгоритм Кнута — Морриса — Пратта

---

**Вопрос 4 (Тема 24: Кучи)**

Какова минимальная высота *d*-ичной кучи, содержащей *n* элементов?

a) ⎣log₂ *n*⎦

b) ⎣log_d *n*⎦

c) ⎡*n* ⁄ *d*⎤

d) ⎣*n* ⁄ log_d *n*⎦

---

**Вопрос 5 (Тема 25: Бинарные кучи)**

В бинарной куче, хранящейся в массиве с индексами от 1, какой индекс имеет родитель элемента с индексом *i*?

a) ⎣*i* ⁄ 2⎦

b) 2 × *i*

c) ⎡*i* ⁄ 2⎤

d) *i* − 1

---

**Вопрос 6 (Тема 26: Фибоначчиева куча)**

Какова амортизированная временная сложность удаления минимального элемента из Фибоначчиевой кучи с *n* элементами?

a) O(log *n*)

b) O(1)

c) O(*n*)

d) O(log log *n*)

---

**Вопрос 7 (Тема 27: Приоритетные очереди)**

Какую структуру данных можно использовать для реализации приоритетной очереди с временем вставки O(1) и временем удаления минимального элемента O(log *n*)?

a) Бинарная куча

b) Двусвязный список

c) Фибоначчиева куча

d) Массив

---

**Вопрос 8 (Тема 28: Деревья отрезков)**

Какова временная сложность обновления значения в точке и запроса суммы на отрезке в дереве отрезков для массива длины *n*?

a) Обе операции O(log *n*)

b) Обновление O(*n*), запрос O(log *n*)

c) Обновление O(log *n*), запрос O(*n*)

d) Обе операции O(1)

---

**Вопрос 9 (Тема 29: Деревья Фенвика)**

Какие операции эффективно поддерживает дерево Фенвика?

a) Запрос суммы на префиксе и обновление элемента

b) Запрос минимума на отрезке и обновление элемента

c) Обновление диапазона и запрос элемента

d) Запрос суммы на отрезке и обновление диапазона

---

**Вопрос 10 (Тема 30: Непересекающиеся множества (Union-Find))**

Какова амортизированная временная сложность выполнения *m* операций над *n* элементами в структуре Union-Find с сжатием путей и объединением по рангу?

a) O(*m* log *n*)

b) O(*m* α(*n*)), где α(*n*) — обратная функция Аккермана

c) O(*n*²)

d) O(*m* + *n*)

---


========================================================================================================================================================================================================


**Вопрос 1 (Скип-листы):**

В скип-листе с \( n \) элементами сколько в среднем потребуется сравнений, чтобы найти заданный элемент?

A) \( O(\log n) \)

B) \( O(\sqrt{n}) \)

C) \( O(n) \)

D) \( O(1) \)

**Ответ:** A) \( O(\log n) \)

---

**Вопрос 2 (Деревья диапазонов):**

Для чего в основном используются деревья диапазонов при работе с многомерными данными?

A) Эффективная работа с одномерными интервалами.

B) Быстрый поиск всех точек внутри заданного прямоугольника.

C) Хранение иерархических отношений в графах.

D) Ускорение поиска ближайшего соседа в одномерном пространстве.

**Ответ:** B) Быстрый поиск всех точек внутри заданного прямоугольника.

---

**Вопрос 3 (Интервальные деревья):**

При поиске пересекающихся интервалов в интервальном дереве какое утверждение верно?

A) Время поиска пропорционально числу хранимых интервалов.

B) Интервальные деревья эффективны только для статических данных.

C) В худшем случае поиск занимает \( O(n) \) времени.

D) Интервальные деревья не поддерживают вставку и удаление элементов.

**Ответ:** C) В худшем случае поиск занимает \( O(n) \) времени.

---

**Вопрос 4 (k-d деревья):**

Что верно относительно эффективности поиска ближайшего соседа в k-d дереве по мере увеличения размерности \( k \)?

A) В худшем случае поиск занимает \( O(k \cdot n) \) времени.

B) Среднее время поиска всегда \( O(\log n) \), независимо от \( k \).

C) Поиск становится менее эффективным при увеличении \( k \).

D) k-d деревья одинаково эффективны для любых \( k \).

**Ответ:** C) Поиск становится менее эффективным при увеличении \( k \).

---

**Вопрос 5 (Квадродеревья):**

Для какого типа данных квадродеревья наиболее подходят?

A) Работа с одномерными числовыми данными.

B) Хранение разреженных матриц.

C) Эффективное индексирование объектов в двумерном пространстве.

D) Обработка трехмерных моделей.

**Ответ:** C) Эффективное индексирование объектов в двумерном пространстве.

---

**Вопрос 6 (Октадеревья):**

Каково основное применение октадеревьев?

A) Сжатие изображений формата JPEG.

B) Оптимизация работы с большими текстовыми файлами.

C) Иерархическое разделение трехмерного пространства.

D) Реализация хеш-таблиц с открытой адресацией.

**Ответ:** C) Иерархическое разделение трехмерного пространства.

---

**Вопрос 7 (Декартовы деревья - treap):**

В декартовом дереве каждый узел имеет ключ и приоритет. Какое утверждение верно?

A) Это куча по ключам и бинарное дерево поиска по приоритетам.

B) Это бинарное дерево поиска по ключам и куча по приоритетам.

C) Балансировка невозможна из-за случайных приоритетов.

D) Это разновидность AVL-дерева с дополнительным приоритетом.

**Ответ:** B) Это бинарное дерево поиска по ключам и куча по приоритетам.

---

**Вопрос 8 (Rope - веревки):**

В чем основное преимущество использования структуры данных "rope" при работе со строками?

A) Быстрая конкатенация и разбиение строк.

B) Экономия памяти при хранении коротких строк.

C) Ускорение поиска подстрок алгоритмом КМП.

D) Обеспечение потокобезопасности при параллельной обработке.

**Ответ:** A) Быстрая конкатенация и разбиение строк.

---

**Вопрос 9 (Блум-фильтры):**

В чем основная особенность блум-фильтра при проверке принадлежности элемента множеству?

A) Точно определяет наличие элемента без ложных срабатываний.

B) Экономит память, допуская возможность ложноположительных результатов.

C) Позволяет удалять элементы без перестройки структуры.

D) Отслеживает количество вхождений каждого элемента.

**Ответ:** B) Экономит память, допуская возможность ложноположительных результатов.

---

**Вопрос 10 (Графы):**

В неориентированном связном графе, содержащем ровно один цикл, число рёбер больше числа вершин на:

A) 1

B) 0

C) Равно числу компонент связности

D) Зависит от структуры графа

**Ответ:** A) 1


========================================================================================================================================================================================================


**Вопрос 1 (Матрицы смежности):**

Сколько различных неориентированных графов без петель можно построить на 3 вершинах? То есть, сколько разных матриц смежности будет у таких графов?

A) 4  
B) 8  
C) 16  
D) 64  

<small>(Правильный ответ: B)</small>

---

**Вопрос 2 (Списки смежности):**

В ориентированном графе без петель с \( n \) вершинами какое максимальное количество ребер может быть? Соответственно, какое максимальное общее число элементов могут иметь списки смежности всех вершин?

A) \( n \)  
B) \( n(n - 1) \)  
C) \( n^2 \)  
D) \( \dfrac{n(n - 1)}{2} \)  

<small>(Правильный ответ: B)</small>

---

**Вопрос 3 (Алгоритмы обхода графов):**

При выполнении поиска в глубину (DFS) в ориентированном графе обнаружено обратное ребро из вершины \( u \) в вершину \( v \). Что можно сказать о временах входа и выхода для этих вершин?

A) Время входа в \( u \) меньше времени входа в \( v \)  
B) Время выхода из \( u \) меньше времени входа в \( v \)  
C) Время входа в \( u \) больше времени выхода из \( v \)  
D) Время выхода из \( u \) больше времени входа в \( v \)  

<small>(Правильный ответ: D)</small>

---

**Вопрос 4 (Хеширование с открытой адресацией):**

При использовании двойного хеширования с функциями \( h_1(k) \) и \( h_2(k) \), где \( h_2(k) \) взаимно проста с размером таблицы \( m \), какое наименьшее простое число нужно выбрать для \( m \), чтобы без переполнения разместить 1000 ключей?

A) 997  
B) 1009  
C) 1013  
D) 2003  

<small>(Правильный ответ: B)</small>

---

**Вопрос 5 (Хеширование с цепочками):**

В хеш-таблице размера \( m \) с \( n \) элементами и равномерной хеш-функцией используется хеширование с цепочками. Каково ожидаемое число сравнений при успешном поиске элемента?

A) \( 1 + \dfrac{\alpha}{2} \), где \( \alpha = \dfrac{n}{m} \)  
B) \( \dfrac{1 - e^{-\alpha}}{\alpha} \)  
C) \( \ln \alpha \)  
D) \( 1 + \alpha \)  

<small>(Правильный ответ: A)</small>

---

**Вопрос 6 (Динамические хеш-таблицы):**

В расширяемом хешировании при добавлении нового элемента глобальная глубина увеличилась на 1. Как изменилась общая емкость (число позиций) хеш-таблицы?

A) Удвоилась  
B) Увеличилась на 1  
C) Не изменилась  
D) Увеличилась на число переполненных блоков  

<small>(Правильный ответ: A)</small>

---

**Вопрос 7 (Куку-хеширование):**

При вставке элемента в куку-хеш-таблицу может потребоваться ре-хеширование из-за циклов перестановок. Какова амортизированная временная сложность операции вставки с учетом возможного ре-хеширования?

A) \( O(1) \)  
B) \( O(\log n) \)  
C) \( O(n) \)  
D) \( O(n \log n) \)  

<small>(Правильный ответ: A)</small>

---

**Вопрос 8 (Множества и мультимножества):**

Имея \( n \) различных элементов, каждый из которых может входить в мультимножество от 0 до \( k \) раз, сколько различных мультимножеств можно составить?

A) \( C(n + k - 1, k - 1) \)  
B) \( \dfrac{(n + k)!}{n! \cdot k!} \)  
C) \( (k + 1)^n \)  
D) \( n^k \)  

<small>(Правильный ответ: C)</small>

---

**Вопрос 9 (Отображения и мультимапы):**

Если мультимапа реализована с помощью сбалансированного бинарного дерева поиска, какова временная сложность поиска всех значений для заданного ключа?

A) \( O(1) \)  
B) \( O(\log n + k) \), где \( k \) — число найденных значений  
C) \( O(n) \)  
D) \( O(k) \)  

<small>(Правильный ответ: B)</small>

---

**Вопрос 10 (Битовые векторы):**

Какова минимальная сложность по числу операций для подсчета количества единиц в битовом векторе длины \( N \) с использованием эффективных алгоритмов подсчета битов?

A) \( O(N) \)  
B) \( O(\log N) \)  
C) \( O\left( \dfrac{N}{\log N} \right) \)  
D) \( O(1) \)  

<small>(Правильный ответ: B)</small>

---


========================================================================================================================================================================================================


Ниже представлены переформулированные вопросы и ответы:

---

**Вопрос 1 (Тема: Деревья суффиксных ссылок)**

Почему в суффиксных деревьях используются суффиксные ссылки и как они ускоряют построение дерева?

A) Помогают быстро находить повторяющиеся символы.

B) Уменьшают количество узлов и экономят память.

C) Ускоряют построение дерева до линейного времени.

D) Обеспечивают совместимость с другими структурами данных.

**Правильный ответ:** C) Ускоряют построение дерева до линейного времени.

---

**Вопрос 2 (Тема: Деревья ван Эмде Боаса)**

Как особенность структуры деревьев ван Эмде Боаса позволяет выполнять операции поиска, вставки и удаления за время O(log log U), где U — размер множества?

A) Используют сбалансированные бинарные кучи.

B) Рекурсивно делят множество на меньшие части.

C) Применяют универсальное хеширование.

D) Используют битовые векторы для хранения данных.

**Правильный ответ:** B) Рекурсивно делят множество на меньшие части.

---

**Вопрос 3 (Тема: Буферные деревья)**

Почему буферные деревья эффективны при работе с большими объемами данных во внешней памяти?

A) Уменьшают глубину дерева, ускоряя доступ.

B) Группируют операции, снижая число операций ввода-вывода.

C) Сжимают данные для экономии места на диске.

D) Позволяют параллельно обрабатывать запросы без конфликтов.

**Правильный ответ:** B) Группируют операции, снижая число операций ввода-вывода.

---

**Вопрос 4 (Тема: Деревья отрезков с ленивым обновлением)**

Что означает "ленивое обновление" в деревьях отрезков и как оно помогает при обновлении диапазонов?

A) Все изменения применяются сразу ко всем узлам.

B) Обновления откладываются до необходимости, уменьшая число операций.

C) Используются дополнительные структуры для ускорения доступа.

D) Узлы хранят историю изменений для возможного отката.

**Правильный ответ:** B) Обновления откладываются до необходимости, уменьшая число операций.

---

**Вопрос 5 (Тема: Модифицированные деревья отрезков)**

Как модифицированные деревья отрезков позволяют эффективно выполнять сложные запросы, например, находить наибольший общий делитель в диапазоне?

A) Хранят в узлах дополнительные параметры для нужных операций.

B) Увеличивают высоту дерева для объединения большего числа элементов.

C) Используют граф вместо дерева для представления данных.

D) Применяют случайность при обновлении узлов для равномерной нагрузки.

**Правильный ответ:** A) Хранят в узлах дополнительные параметры для нужных операций.

---

**Вопрос 6 (Тема: Деревья интервальных максимумов)**

Для решения каких задач используются деревья интервальных максимумов и в чем их преимущество?

A) Быстро находят пересекающиеся интервалы.

B) Моментально предоставляют минимальное значение в диапазоне.

C) Ускоряют вставку и удаление элементов.

D) Поддерживают добавление интервалов без перестройки дерева.

**Правильный ответ:** A) Быстро находят пересекающиеся интервалы.

---

**Вопрос 7 (Тема: Деревья интервалов отрезков)**

В чем ключевое отличие дерева интервалов отрезков от обычного дерева отрезков и для каких задач оно эффективно?

A) Хранит несмежные диапазоны, подходя для разреженных данных.

B) Объединяет хеш-таблицу и дерево для быстрого поиска.

C) В узлах хранятся интервалы, что эффективно при их пересечении.

D) Использует меньше памяти, оптимально для встроенных систем.

**Правильный ответ:** C) В узлах хранятся интервалы, что эффективно при их пересечении.

---

**Вопрос 8 (Тема: Деревья поиска с поддеревьями)**

Как добавление информации о размерах поддеревьев в узлы дерева поиска улучшает его работу и какие операции ускоряет?

A) Позволяет быстро выполнять ранговые запросы и находить k-й элемент.

B) Ускоряет поиск минимального и максимального элементов до O(1).

C) Автоматически балансирует дерево без дополнительных алгоритмов.

D) Улучшает производительность при последовательном доступе к элементам.

**Правильный ответ:** A) Позволяет быстро выполнять ранговые запросы и находить k-й элемент.

---

**Вопрос 9 (Тема: Деревья порядковых статистик)**

Какую дополнительную информацию хранит каждый узел в дереве порядковых статистик и как это используется?

A) Глубину узла для быстрой балансировки дерева.

B) Ключ наибольшего предка для ускорения поиска.

C) Количество узлов в поддеревьях для определения ранга элемента.

D) Сумму значений потомков для агрегатных запросов.

**Правильный ответ:** C) Количество узлов в поддеревьях для определения ранга элемента.

---

**Вопрос 10 (Тема: Весовые балансирующие деревья)**

Как весовые балансирующие деревья поддерживают равновесие и какие свойства используют для контроля структуры?

A) Поддерживают равные глубины левого и правого поддеревьев.

B) Используют веса узлов — количество потомков — для контроля дисбаланса.

C) Случайно перестраивают дерево при обнаружении дисбаланса.

D) Ограничивают число элементов на каждом уровне фиксированным значением.

**Правильный ответ:** B) Используют веса узлов — количество потомков — для контроля дисбаланса.

---


========================================================================================================================================================================================================


**Вопрос 1 (Тема 61 - Имерсивные деревья):**

Что понимается под иммерсивными (имплицитными) деревьями в структурах данных?

A) Деревья, явно представленные узлами и указателями на потомков.

B) Деревья, реализованные без указателей, с вычислением позиций узлов в массиве.

C) Деревья, которые используют хеш-таблицы для быстрого доступа к элементам.

D) Деревья, автоматически балансирующиеся после каждой вставки.

**Ответ:**

B) Деревья, реализованные без указателей, с вычислением позиций узлов в массиве.

---

**Вопрос 2 (Тема 62 - Функциональные (персистентные) структуры данных):**

Какое преимущество функциональных (персистентных) структур данных в многопоточных приложениях?

A) Они позволяют изменять данные без создания новых копий.

B) Они упрощают синхронизацию, позволяя потокам безопасно работать с общими данными без блокировок.

C) Они всегда занимают меньше памяти по сравнению с обычными структурами данных.

D) Они не применимы в функциональных языках программирования.

**Ответ:**

B) Они упрощают синхронизацию, позволяя потокам безопасно работать с общими данными без блокировок.

---

**Вопрос 3 (Тема 63 - Непрерывные структуры данных):**

В каких случаях целесообразно использовать непрерывные структуры данных?

A) При работе с базами данных, содержащими дискретные записи.

B) При моделировании и вычислениях в компьютерной графике и геометрии.

C) При сортировке целочисленных массивов.

D) Для оптимизации доступа в больших хеш-таблицах.

**Ответ:**

B) При моделировании и вычислениях в компьютерной графике и геометрии.

---

**Вопрос 4 (Тема 64 - Иммутабельные структуры данных):**

Какое утверждение верно об иммутабельных структурах данных?

A) Их элементы можно изменять без создания новых версий структуры.

B) Они облегчают отслеживание изменений состояния программы.

C) Они всегда используют меньше памяти, чем изменяемые структуры.

D) Они не подходят для функционального программирования.

**Ответ:**

B) Они облегчают отслеживание изменений состояния программы.

---

**Вопрос 5 (Тема 65 - Конкурентные (параллельные) структуры данных):**

Какой подход помогает избежать взаимоблокировок в параллельных структурах данных?

A) Использование глобальных блокировок для всей структуры.

B) Применение алгоритмов без блокировок и атомарных операций.

C) Последовательное выполнение потоков.

D) Отказ от использования структур данных в многопоточности.

**Ответ:**

B) Применение алгоритмов без блокировок и атомарных операций.

---

**Вопрос 6 (Тема 66 - Безблокирующие (lock-free) структуры данных):**

Что является главным свойством безблокирующих (lock-free) структур данных?

A) Каждая операция завершается за ограниченное число шагов независимо от других потоков.

B) Отсутствие затрат на синхронизацию благодаря небезопасным операциям.

C) Система в целом продолжает работать, даже если отдельные потоки приостановлены.

D) Использование краткосрочных блокировок для повышения скорости.

**Ответ:**

C) Система в целом продолжает работать, даже если отдельные потоки приостановлены.

---

**Вопрос 7 (Тема 67 - Беспредельные (wait-free) структуры данных):**

В чем ключевое отличие беспредельных (wait-free) структур данных от безблокирующих?

A) Они требуют больше памяти для хранения промежуточных данных.

B) Каждая операция завершается за ограниченное число шагов независимо от других потоков.

C) Они используют блокировки для предотвращения взаимоблокировок.

D) Они менее эффективны в многопоточной среде.

**Ответ:**

B) Каждая операция завершается за ограниченное число шагов независимо от других потоков.

---

**Вопрос 8 (Тема 68 - Деревья с пространственным индексированием):**

Для какого типа данных деревья с пространственным индексированием наиболее эффективны?

A) Для текстовых данных в больших документах.

B) Для географических координат и объектов в многомерном пространстве.

C) Для логических выражений и булевых функций.

D) Для последовательностей ДНК в биоинформатике.

**Ответ:**

B) Для географических координат и объектов в многомерном пространстве.

---

**Вопрос 9 (Тема 69 - R-деревья):**

Как R-деревья обеспечивают эффективный поиск пространственных объектов?

A) Разбивают данные на фиксированную сетку.

B) Группируют близкие объекты в иерархию вложенных прямоугольников.

C) Строят сбалансированное двоичное дерево на основе расстояний.

D) Хешируют координаты для быстрого доступа.

**Ответ:**

B) Группируют близкие объекты в иерархию вложенных прямоугольников.

---

**Вопрос 10 (Тема 70 - R*-деревья):**

Какое улучшение R*-деревья предлагают по сравнению с обычными R-деревьями?

A) Упрощают вставку, отказываясь от переупорядочивания узлов.

B) Снижают перекрытие областей, оптимизируя разбиение при вставке и удалении.

C) Ограничивают количество уровней дерева для ускорения поиска.

D) Случайно перестраивают дерево для равномерного распределения данных.

**Ответ:**

B) Снижают перекрытие областей, оптимизируя разбиение при вставке и удалении.


========================================================================================================================================================================================================


**Вопрос 1 (Тема 71: X-деревья)**

Как X-дерево справляется с "проклятием размерности" при работе с данными высокой размерности?

A) Использует суперузлы, чтобы избежать излишнего разбиения.

B) Применяет случайное проецирование для уменьшения размерности данных.

C) Использует хеширование для распределения данных по узлам.

D) Переходит на линейный поиск для повышения скорости.

**Правильный ответ:** A) Использует суперузлы, чтобы избежать излишнего разбиения.

---

**Вопрос 2 (Тема 72: M-деревья)**

В чём основное преимущество M-деревьев при поиске в метрических пространствах?

A) Используют координаты объектов для быстрого доступа.

B) Позволяют искать по расстоянию между объектами без знания их координат.

C) Сжимают данные для экономии места.

D) Используют хеширование метрик для ускорения поиска.

**Правильный ответ:** B) Позволяют искать по расстоянию между объектами без знания их координат.

---

**Вопрос 3 (Тема 73: Индексные структуры для БД)**

Какая индексная структура наиболее эффективна для диапазонных запросов в базах данных?

A) Хеш-индексы.

B) B+-деревья.

C) Битовые индексы.

D) Прямые файлы.

**Правильный ответ:** B) B+-деревья.

---

**Вопрос 4 (Тема 74: Индексы на основе хешей)**

Какое основное ограничение хеш-индексов по сравнению с деревьями в базах данных?

A) Занимают больше места на диске.

B) Не поддерживают эффективные диапазонные запросы.

C) Сложнее обновляются при изменении данных.

D) Работают только с числовыми данными.

**Правильный ответ:** B) Не поддерживают эффективные диапазонные запросы.

---

**Вопрос 5 (Тема 75: Файлы с индексом по B-дереву)**

Почему файлы с индексом по B-дереву эффективны при работе с большими объёмами данных на диске?

A) Все данные хранятся в корневом узле, что сокращает доступы к диску.

B) Высокая ветвистость дерева уменьшает число дисковых операций при поиске.

C) Используют хеширование для быстрого доступа к данным.

D) Позволяют сжимать данные для экономии места.

**Правильный ответ:** B) Высокая ветвистость дерева уменьшает число дисковых операций при поиске.

---

**Вопрос 6 (Тема 76: Splay-деревья)**

Что отличает splay-деревья от других самобалансирующихся деревьев поиска?

A) Используют случайность при вставке и удалении элементов.

B) Часто используемые элементы перемещаются ближе к корню дерева.

C) Балансировка достигается вращениями узлов на каждом уровне.

D) Хранят высоту поддеревьев для поддержания баланса.

**Правильный ответ:** B) Часто используемые элементы перемещаются ближе к корню дерева.

---

**Вопрос 7 (Тема 77: Деревья покрытия)**

Почему деревья покрытия (Cover Trees) эффективны для поиска ближайших соседей в пространствах высокой размерности?

A) Обеспечивают постоянное время поиска.

B) Гарантируют логарифмическое время поиска независимо от размерности.

C) Сокращают вычисления с помощью сжатия данных.

D) Используют хеширование для ускорения поиска.

**Правильный ответ:** B) Гарантируют логарифмическое время поиска независимо от размерности.

---

**Вопрос 8 (Тема 78: Деревья интервалов)**

Для какой задачи чаще всего используются деревья интервалов?

A) Поиск точек, находящихся внутри заданного интервала.

B) Поиск ближайшего соседа в наборе данных.

C) Хранение и обработка временных меток событий.

D) Сжатие и индексирование текстовой информации.

**Правильный ответ:** A) Поиск точек, находящихся внутри заданного интервала.

---

**Вопрос 9 (Тема 79: Гиперкубы)**

Какое свойство гиперкубов делает их привлекательными для построения параллельных вычислительных систем?

A) Небольшая степень связи узлов.

B) Прямое соединение между любыми двумя узлами.

C) Логарифмическая длина пути между узлами от общего числа узлов.

D) Простота расширения сети при увеличении узлов.

**Правильный ответ:** C) Логарифмическая длина пути между узлами от общего числа узлов.

---

**Вопрос 10 (Тема 80: Распределённые хеш-таблицы (DHT))**

Какое основное свойство распределённых хеш-таблиц обеспечивает их масштабируемость и устойчивость в одноранговых сетях?

A) Централизованное управление и хранение данных.

B) Динамическое хеширование для равномерного распределения данных по узлам.

C) Хранение полной копии всех данных на каждом узле сети.

D) Ограничение количества узлов для поддержания стабильности.

**Правильный ответ:** B) Динамическое хеширование для равномерного распределения данных по узлам.


========================================================================================================================================================================================================


Вопрос 1:

В распределённой системе, использующей консистентное хеширование для распределения данных между узлами, при добавлении нового узла какая доля ключей в среднем будет перемещена на него?

A) Все ключи.

B) Только ключи, назначенные новому узлу.

C) Примерно 1/N всех ключей, где N — общее число узлов после добавления.

D) Ключи не будут перемещены.

**Ответ:** C) Примерно 1/N всех ключей, где N — общее число узлов после добавления.

---

Вопрос 2:

Почему **skip-графы** обеспечивают лучшую балансировку нагрузки и отказоустойчивость в распределённых системах по сравнению с некоторыми другими структурами данных?

A) Потому что используют случайные связи для равномерного распределения нагрузки.

B) Потому что основаны на двоичных деревьях, что позволяет быстро находить данные.

C) Потому что имеют многоуровневую структуру с избыточными связями, повышающими надёжность.

D) Потому что каждый узел хранит полную копию данных.

**Ответ:** C) Потому что имеют многоуровневую структуру с избыточными связями, повышающими надёжность.

---

Вопрос 3:

В **конденсированномTrie** (патриция-три) для оптимизации хранения строковых ключей используется следующий метод:

A) Применение битовых масок для быстрого сравнения префиксов.

B) Объединение узлов с единственным потомком для уменьшения глубины дерева.

C) Использование хеш-функций для прямого доступа к узлам.

D) Хранение частоты символов для ускорения поиска.

**Ответ:** B) Объединение узлов с единственным потомком для уменьшения глубины дерева.

---

Вопрос 4:

Какое основное преимущество использования **crit-bit деревьев** при хранении и поиске данных?

A) Сокращение количества сравнений за счёт сжатия путей.

B) Упрощение параллельной обработки данных.

C) Повышение точности поиска благодаря дополнительным метаданным.

D) Ускорение вставки данных через динамическое балансирование.

**Ответ:** A) Сокращение количества сравнений за счёт сжатия путей.

---

Вопрос 5:

Как в **деревьях жирных узлов** реализуется сохранение прошлых версий данных (персистентность)?

A) Копированием и сохранением всего дерева при каждом изменении.

B) Хранением всех версий изменённых узлов внутри самих узлов.

C) Использованием временных меток для восстановления предыдущих состояний.

D) Применением обратимых операций для отслеживания изменений.

**Ответ:** B) Хранением всех версий изменённых узлов внутри самих узлов.

---

Вопрос 6:

В чём ключевое отличие **суффиксного автомата** от суффиксного дерева при работе с подстроками строки?

A) Суффиксный автомат содержит меньше состояний и использует память эффективнее.

B) Суффиксный автомат может обрабатывать только строки фиксированной длины.

C) Суффиксный автомат не позволяет быстро находить повторяющиеся подстроки.

D) Построение суффиксного автомата занимает больше времени, чем суффиксного дерева.

**Ответ:** A) Суффиксный автомат содержит меньше состояний и использует память эффективнее.

---

Вопрос 7:

Каково минимальное число узлов в **палиндромическом дереве** (эертри) для строки из разных символов, не образующих палиндромов?

A) Два узла: для пустого палиндрома и для одиночных символов.

B) Число узлов равно длине строки.

C) Один узел для пустого палиндрома.

D) Узлов нет, так как палиндромы отсутствуют.

**Ответ:** A) Два узла: для пустого палиндрома и для одиночных символов.

---

Вопрос 8:

Какая операция отличает **динамические деревья** от статических и позволяет эффективно решать задачи на динамических графах?

A) Быстрое удаление листьев дерева.

B) Соединение и разрезание поддеревьев.

C) Изменение значений в узлах без изменения структуры дерева.

D) Поддержание баланса дерева при добавлении новых узлов.

**Ответ:** B) Соединение и разрезание поддеревьев.

---

Вопрос 9:

Какова амортизированная временная сложность операции доступа к пути между двумя узлами в **Link-Cut деревьях**?

A) O(1)

B) O(log N), где N — число узлов в дереве.

C) O(N)

D) O(N log N)

**Ответ:** B) O(log N), где N — число узлов в дереве.

---

Вопрос 10:

Какое преимущество даёт представление дерева с помощью **обхода Эйлера** (Euler Tour) при выполнении операций над деревом?

A) Позволяет преобразовать дерево в массив для эффективной обработки запросов.

B) Обеспечивает доступ к любому узлу за постоянное время.

C) Уменьшает объём используемой памяти за счёт удаления лишних связей.

D) Упрощает параллельную обработку благодаря независимости ветвей.

**Ответ:** A) Позволяет преобразовать дерево в массив для эффективной обработки запросов.


========================================================================================================================================================================================================


1. **Тема 91: Деревья тяжёлого пути (Heavy Light Decomposition)**

   **Вопрос:**
   Зачем используют декомпозицию дерева тяжёлого пути (HLD) при работе с деревьями?

   A) Для быстрого выполнения операций на пути между любыми двумя узлами

   B) Чтобы упростить поиск ближайшего общего предка

   C) Для балансировки дерева и уменьшения его высоты

   D) Чтобы преобразовать дерево в двоичное дерево поиска

   **Правильный ответ:** A) Для быстрого выполнения операций на пути между любыми двумя узлами

2. **Тема 92: Центроидная декомпозиция**

   **Вопрос:**
   Чем полезна центроидная декомпозиция в задачах на деревьях?

   A) Разбивает дерево на части для параллельной обработки

   B) Позволяет эффективно отвечать на запросы о поддеревьях и путях

   C) Уменьшает диаметр дерева для ускорения поиска

   D) Оптимизирует рекурсивные алгоритмы на деревьях

   **Правильный ответ:** B) Позволяет эффективно отвечать на запросы о поддеревьях и путях

3. **Тема 93: Комбинированные структуры данных**

   **Вопрос:**
   Какая структура данных сочетает свойства кучи и дека для эффективной реализации двусторонней очереди с возможностью извлечения минимального элемента?

   A) Биномиальная куча

   B) Декартово дерево

   C) Левая куча

   D) Гребенка (Comb)

   **Правильный ответ:** B) Декартово дерево

4. **Тема 94: Сжатые структуры данных**

   **Вопрос:**
   Что верно о сжатых структурах данных?

   A) Они работают только с текстовой информацией

   B) Они уменьшают скорость доступа ради экономии памяти

   C) Позволяют выполнять операции без полной распаковки данных

   D) Используют сжатие с потерями для уменьшения размера

   **Правильный ответ:** C) Позволяют выполнять операции без полной распаковки данных

5. **Тема 95: Волновые деревья (Wavelet Trees)**

   **Вопрос:**
   Для какой задачи лучше всего подходят волновые деревья?

   A) Поиск подстрок в строке

   B) Хранение двумерных точек для поиска соседей

   C) Обработка запросов ранга и выбора в последовательности символов

   D) Индексация и извлечение в динамических множествах

   **Правильный ответ:** C) Обработка запросов ранга и выбора в последовательности символов

6. **Тема 96: Сукцинктные структуры данных**

   **Вопрос:**
   Чем отличаются сукцинктные структуры данных?

   A) Хранят данные в зашифрованном виде

   B) Используют минимальную память, сохраняя эффективность операций

   C) Предназначены только для облачных систем

   D) Не поддерживают изменение данных после создания

   **Правильный ответ:** B) Используют минимальную память, сохраняя эффективность операций

7. **Тема 97: Структуры ранга и выборки**

   **Вопрос:**
   Как в битовой последовательности длины \( n \) за постоянное время отвечать на запросы ранга и выбора с минимальным дополнительным пространством?

   A) Использовать битовый массив с предвычислениями

   B) Построить суффиксное дерево

   C) Применить сукцинктное индексирование с малой избыточностью

   D) Использовать двоичное дерево поиска

   **Правильный ответ:** C) Применить сукцинктное индексирование с малой избыточностью

8. **Тема 98: Двойное хеширование**

   **Вопрос:**
   Какую проблему решает двойное хеширование в хеш-таблицах?

   A) Ускоряет вычисление хеш-функции

   B) Уменьшает коллизии и кластеризацию при вставке элементов

   C) Снижает использование памяти при хранении данных

   D) Обеспечивает упорядоченный доступ к элементам

   **Правильный ответ:** B) Уменьшает коллизии и кластеризацию при вставке элементов

9. **Тема 99: Левосторонние кучи**

   **Вопрос:**
   Как левосторонние кучи эффективно объединяют две кучи?

   A) Поддерживая строго сбалансированное дерево

   B) Используя ранг узлов и перестраивая дерево

   C) Минимизируя высоту правых поддеревьев, сохраняя "левость"

   D) Применяя вращения, как в AVL-деревьях

   **Правильный ответ:** C) Минимизируя высоту правых поддеревьев, сохраняя "левость"

10. **Тема 100: Парные кучи (Pairing Heaps)**

    **Вопрос:**
    Что верно о парных кучах?

    A) Операция вставки всегда занимает \( O(1) \) время

    B) Операция уменьшения ключа имеет амортизированную сложность \( O(\log n) \)

    C) Они менее эффективны при объединении куч, чем бинарные кучи

    D) Их реализация очень сложна из-за используемых структур

    **Правильный ответ:** B) Операция уменьшения ключа имеет амортизированную сложность \( O(\log n) \)


========================================================================================================================================================================================================


**Вопрос 1 (Тема 101: Троичные кучи)**

Какова высота полной троичной кучи с \( n \) узлами и какова сложность операции вставки элемента в такую кучу?

A) Высота \( O(\log n) \), вставка за \( O(1) \)

B) Высота \( O(\log_3 n) \), вставка за \( O(\log_3 n) \)

C) Высота \( O(\log_3 n) \), вставка за \( O(\log n) \)

D) Высота \( O(\log n) \), вставка за \( O(\log n) \)

**Правильный ответ:** B

---

**Вопрос 2 (Тема 102: Дек с максимальным приоритетом)**

Какую структуру данных лучше всего использовать для реализации дека, позволяющего удалять как максимальный, так и минимальный элементы за логарифмическое время?

A) Две отдельные кучи: минимальную и максимальную

B) Двойная куча (double-ended heap)

C) Дек на основе самобалансирующегося дерева поиска

D) Приоритетная очередь на базе двоичной кучи

**Правильный ответ:** B

---

**Вопрос 3 (Тема 103: Имунные структуры данных)**

Чем имунные структуры данных отличаются от неизменяемых структур данных?

A) Позволяют изменять данные без копирования всей структуры

B) Защищают от одновременного доступа в многопоточном окружении

C) Сохраняют предыдущие версии для возможного отката изменений

D) Устойчивы к переполнению буфера и связанным атакам

**Правильный ответ:** D

---

**Вопрос 4 (Тема 104: Линейные простые цепи)**

Как можно описать линейную простую цепь и ее применение?

A) Циклический граф с оптимизированным поиском

B) Последовательность узлов, где каждый связан только с соседними узлами

C) Структура для реализации хеш-таблиц с открытой адресацией

D) Метод для построения минимальных остовных деревьев

**Правильный ответ:** B

---

**Вопрос 5 (Тема 105: Spaghetti Stack)**

В чем основное преимущество структуры данных "Spaghetti Stack"?

A) Эффективное управление памятью при рекурсивных вызовах

B) Поддержка нелокальных переходов и сохранение состояния подпрограмм

C) Улучшение кеширования при глубоком стеке вызовов

D) Упрощение многопоточности без необходимости синхронизации

**Правильный ответ:** B

---

**Вопрос 6 (Тема 106: Монтажные списки)**

Как монтажные списки способствуют оптимизации работы с последовательностями данных в функциональных языках?

A) Позволяют изменять начало списка без копирования всей структуры

B) Обеспечивают доступ по индексу за постоянное время

C) Упрощают вставку и удаление элементов в середине списка

D) Снижают нагрузку на сборщик мусора благодаря статической памяти

**Правильный ответ:** A

---

**Вопрос 7 (Тема 107: Расширяемые массивы)**

В расширяемых массивах с сегментацией какая операция становится эффективнее по сравнению с обычными динамическими массивами?

A) Доступ к элементам по индексу

B) Добавление элемента в конец массива

C) Удаление элемента из середины массива

D) Вставка элемента в начало массива

**Правильный ответ:** D

---

**Вопрос 8 (Тема 108: Кольцевые буферы)**

Какое утверждение верно для кольцевого буфера с одним указателем чтения/записи в однопоточном приложении?

A) Может незаметно переполниться

B) Требует дополнительных механизмов синхронизации

C) Размер должен быть простым числом для равномерности

D) Обеспечивает эффективную очередь FIFO с постоянным временем операций

**Правильный ответ:** D

---

**Вопрос 9 (Тема 109: Комбинированные хеш-функции)**

Как можно снизить вероятность коллизий при хешировании сложных объектов?

A) Просто объединить хеши полей без обработки

B) Использовать криптографические хеш-функции для каждого поля

C) Суммировать хеши полей с умножением на простые числа

D) Применить одну хеш-функцию к сериализованному объекту

**Правильный ответ:** C

---

**Вопрос 10 (Тема 110: Алгоритмы хеширования строк)**

Какой алгоритм хеширования строк использует полиномиальное хеширование и позволяет быстро вычислять хеши подстрок после предварительной обработки?

A) Алгоритм Бойера-Мура

B) Скользящий хеш (Rolling Hash)

C) Алгоритм Кнута-Морриса-Пратта

D) Суффиксное дерево

**Правильный ответ:** B


========================================================================================================================================================================================================


Вот переработанные вопросы и ответы:

---

**Вопрос 1 (Тема 111: Rolling Hash):**

В чем главное преимущество использования скользящего хеша (Rolling Hash) при поиске подстрок в строке?

A) Он дает уникальное хеш-значение для каждой подстроки.

B) Позволяет быстро обновлять хеш при сдвиге на один символ.

C) Уменьшает количество коллизий за счет криптографической сложности.

D) Вычисляет хеш подстроки за постоянное время независимо от ее длины.

**Правильный ответ:** B

---

**Вопрос 2 (Тема 112: MinHash):**

Для чего используется алгоритм MinHash в анализе больших данных?

A) Точное вычисление пересечения двух больших множеств.

B) Ускорение поиска в хеш-таблицах.

C) Приближенная оценка сходства между большими множествами.

D) Максимальное сжатие данных без потерь.

**Правильный ответ:** C

---

**Вопрос 3 (Тема 113: Древовидные коды):**

Какое свойство древовидных кодов делает их полезными для надежной передачи информации?

A) Постоянное относительное расстояние между кодовыми словами.

B) Восстановление данных без избыточности.

C) Быстрое кодирование и декодирование больших объемов данных.

D) Адаптация к изменению условий связи.

**Правильный ответ:** A

---

**Вопрос 4 (Тема 114: Деревья решений):**

Как можно предотвратить переобучение в деревьях решений?

A) Увеличить глубину и количество узлов дерева.

B) Использовать все доступные признаки без отбора.

C) Применить обрезку (pruning) ненужных ветвей.

D) Игнорировать отсутствующие данные в выборке.

**Правильный ответ:** C

---

**Вопрос 5 (Тема 115: Кучи приоритетов):**

Чем фибоначчиева куча превосходит бинарную при работе с приоритетами?

A) Быстрее извлекает минимальный элемент.

B) Ускоряет уменьшение ключа до амортизированного O(1).

C) Требует меньше памяти из-за компактности.

D) Упрощает вставку новых элементов.

**Правильный ответ:** B

---

**Вопрос 6 (Тема 116: Главные файлы):**

Какова основная роль главного файла в системах управления данными?

A) Хранит все транзакции системы в журнале.

B) Обеспечивает резервное копирование после сбоев.

C) Содержит актуальную информацию о ключевых объектах.

D) Временно хранит данные для промежуточных вычислений.

**Правильный ответ:** C

---

**Вопрос 7 (Тема 117: Кучи для внешней памяти):**

Какую кучу предпочтительно использовать с данными, не помещающимися в оперативную память, чтобы сократить операции ввода-вывода?

A) Бинарную кучу

B) Фибоначчиеву кучу

C) Буферную кучу (Buffer Heap)

D) Биномиальную кучу

**Правильный ответ:** C

---

**Вопрос 8 (Тема 118: Деревья буферов):**

Что позволяет деревьям буферов эффективно работать с большими данными на внешних носителях?

A) Буферы в узлах для пакетной обработки операций.

B) Самобалансировка для минимальной высоты дерева.

C) Хранение данных в листьях для быстрого доступа.

D) Использование хеширования для распределения данных.

**Правильный ответ:** A

---

**Вопрос 9 (Тема 119: Деревья дифференцирования):**

Для чего используются деревья дифференцирования в системах контроля версий?

A) Быстро сливают параллельные изменения в файлах.

B) Эффективно хранят и управляют различиями между версиями.

C) Обнаруживают конфликты при редактировании файлов.

D) Автоматически резервируют данные на внешних носителях.

**Правильный ответ:** B

---

**Вопрос 10 (Тема 120: Гиперсети):**

Чем гиперсеть (гиперграф) отличается от обычного графа?

A) Узлы могут иметь петли, а в графах это запрещено.

B) Ребра могут соединять более двух узлов одновременно.

C) Гиперсети всегда являются планарными, в отличие от графов.

D) В гиперсетях нет циклов, а в графах они возможны.

**Правильный ответ:** B

---


========================================================================================================================================================================================================


**Вопрос 1** (Тема 121: Матричные деревья)

Как можно использовать матрицу Кирхгофа для вычисления количества остовных деревьев во взвешенном графе?

A) Матрица Кирхгофа не учитывает веса ребер  
B) Она позволяет вычислить число остовных деревьев с учетом весов  
C) Собственные значения матрицы смежности дают это число  
D) Метод работает только для невзвешенных графов  

**Правильный ответ:** B

---

**Вопрос 2** (Тема 122: Структуры данных для быстрого поиска)

Какая структура данных обеспечивает время поиска элемента O(log log n) в худшем случае для упорядоченных целых чисел?

A) Красно-черное дерево  
B) Дерево ван Эмде Боаса  
C) Хеш-таблица  
D) Skip-список  

**Правильный ответ:** B

---

**Вопрос 3** (Тема 123: Пространственные деревья)

Каким образом k-d дерево разбивает пространство при индексировании точек?

A) По значениям хеш-функции  
B) С помощью гиперплоскостей в евклидовом пространстве  
C) Сформировывая многомерные сферы  
D) Группируя точки в кластеры признаков  

**Правильный ответ:** B

---

**Вопрос 4** (Тема 124: Хэш-кучи)

В чем преимущество хэш-кучи перед обычной кучей при реализации приоритетной очереди?

A) Быстрое объединение куч  
B) Мгновенный доступ к любому элементу  
C) Экономия памяти за счет хеширования  
D) Улучшенная балансировка структуры  

**Правильный ответ:** B

---

**Вопрос 5** (Тема 125: Модифицированные хэш-таблицы)

Какая особенность отличает упорядоченную хеш-таблицу от стандартной?

A) Хранение нескольких значений по одному ключу  
B) Сохранение порядка элементов при добавлении  
C) Постоянное время доступа к новым элементам  
D) Отсутствие перестроек при заполнении  

**Правильный ответ:** B

---

**Вопрос 6** (Тема 126: Квотные фильтры)

В чем преимущество квотного фильтра перед блум-фильтром в условиях ограниченной памяти?

A) Нет ложных срабатываний  
B) Можно удалять элементы из фильтра  
C) Быстрая инициализация фильтра  
D) Меньше хеш-функций без увеличения ошибок  

**Правильный ответ:** B

---

**Вопрос 7** (Тема 127: Гиперлог-лог)

Для чего используется алгоритм HyperLogLog в анализе больших данных?

A) Точный подсчет уникальных элементов  
B) Приближенный подсчет уникальных элементов с малым расходом памяти  
C) Построение гистограмм в реальном времени  
D) Поиск самого частого элемента  

**Правильный ответ:** B

---

**Вопрос 8** (Тема 128: Вариативные структуры данных)

Какое свойство вариативных структур данных полезно для систем с версионированием?

A) Автоматическое масштабирование  
B) Управление разными версиями без дублирования данных  
C) Потокобезопасность через изменяемость  
D) Повышение производительности при изменении структуры  

**Правильный ответ:** B

---

**Вопрос 9** (Тема 129: Структуры данных с подвижными элементами)

Какую структуру данных лучше использовать для эффективного редактирования и перемещения больших текстовых фрагментов в редакторах?

A) Динамический массив  
B) Веревка (Rope)  
C) Двусвязный список  
D) Суффиксное дерево  

**Правильный ответ:** B

---

**Вопрос 10** (Тема 130: Оценочные структуры данных)

Какая структура данных позволяет с ограниченной памятью оценивать частоту элементов в потоке данных с контролируемой ошибкой?

A) Count-Min Sketch  
B) Бинарное дерево поиска  
C) Хеш-таблица  
D) Skip-список  

**Правильный ответ:** A


========================================================================================================================================================================================================


**Вопрос 1 (Тема: 131. Адаптивные структуры данных)**

Какой основной принцип помогает адаптивным структурам данных оптимизировать операции при изменении паттернов доступа?

A) Статическая балансировка для постоянной производительности  
B) Случайная перестановка элементов для равномерной нагрузки  
C) Динамическая перестройка структуры на основе текущего доступа  
D) Добавление избыточных данных для ускорения доступа  

**Правильный ответ:**  
C) Динамическая перестройка структуры на основе текущего доступа

---

**Вопрос 2 (Тема: 132. Структуры данных с самокоррекцией)**

Какое преимущество дают структуры данных с самокоррекцией при частых изменениях данных?

A) Автоматически восстанавливаются после аппаратных сбоев  
B) Адаптируются к ошибкам в алгоритмах без вмешательства  
C) Поддерживают эффективность без перестройки структуры  
D) Корректируют свою конфигурацию для сохранения производительности  

**Правильный ответ:**  
D) Корректируют свою конфигурацию для сохранения производительности

---

**Вопрос 3 (Тема: 133. Панкучные деревья)**

Какой уникальный метод используется в панкучных деревьях для поддержания порядка элементов?

A) Повороты узлов для балансировки  
B) Разбиение и слияние поддеревьев  
C) Переворачивание сегментов для перестановки элементов  
D) Использование дополнительных индексов для быстрого доступа  

**Правильный ответ:**  
C) Переворачивание сегментов для перестановки элементов

---

**Вопрос 4 (Тема: 134. Большие кучи)**

Как эффективно работать с большими кучами, которые не помещаются в оперативной памяти?

A) Использовать внешние сортировки и многоэтапную обработку  
B) Хранить элементы кучи в связных списках  
C) Разбивать кучу между узлами сети  
D) Использовать многопоточность для обработки в памяти  

**Правильный ответ:**  
A) Использовать внешние сортировки и многоэтапную обработку

---

**Вопрос 5 (Тема: 135. Глубокие деревья)**

Какой основной недостаток глубоких деревьев при поиске и как его уменьшить?

A) Долгое время доступа из-за высоты; применять сбалансированные деревья  
B) Сложность поддержки структуры; использовать хеширование  
C) Большой объём памяти; сжимать структуру данных  
D) Трудно параллелить; разбивать дерево на части  

**Правильный ответ:**  
A) Долгое время доступа из-за высоты; применять сбалансированные деревья

---

**Вопрос 6 (Тема: 136. Равновесные деревья)**

В чем особенность равновесных деревьев по сравнению с другими сбалансированными деревьями?

A) Всегда идеально сбалансированы после каждой операции  
B) Допускают небольшой дисбаланс для ускорения некоторых операций  
C) Не хранят информацию о высоте узлов  
D) Используют случайные перестановки для сохранения структуры  

**Правильный ответ:**  
B) Допускают небольшой дисбаланс для ускорения некоторых операций

---

**Вопрос 7 (Тема: 137. Структуры данных со случайизацией)**

Как случайность в структурах данных, например, скип-листах, влияет на сложность операций в худшем случае?

A) Увеличивает сложность до экспоненциальной  
B) Дает постоянную сложность операций  
C) Снижает шанс худшего случая до минимума  
D) Не снижает худшую сложность, но улучшает среднюю  

**Правильный ответ:**  
D) Не снижает худшую сложность, но улучшает среднюю

---

**Вопрос 8 (Тема: 138. Самонастраивающиеся деревья)**

Как самонастраивающиеся деревья, такие как splay-деревья, повышают эффективность последовательных поисков?

A) Перемещают часто используемые элементы ближе к корню  
B) Периодически перестраивают дерево по статистике доступа  
C) Используют дополнительные индексы для быстрого доступа  
D) Ограничивают глубину за счет дублирования данных  

**Правильный ответ:**  
A) Перемещают часто используемые элементы ближе к корню

---

**Вопрос 9 (Тема: 139. Квантильные деревья)**

Какова основная цель использования квантильных деревьев в анализе данных?

A) Хранить иерархические кластеры данных  
B) Быстро вычислять квантили и перцентили в динамических наборах  
C) Уменьшать размер данных для визуализации  
D) Улучшать поиск ближайшего соседа  

**Правильный ответ:**  
B) Быстро вычислять квантили и перцентили в динамических наборах

---

**Вопрос 10 (Тема: 140. Структуры данных для массивов)**

Как эффективно выполнять вставку и удаление в середине большого массива без смещения многих элементов?

A) Использовать динамический массив  
B) Применять деревья ван Эмде Боаса для индексации  
C) Использовать буфер с разрывом (gap buffer) для локальных изменений  
D) Преобразовать массив в связный список  

**Правильный ответ:**  
C) Использовать буфер с разрывом (gap buffer) для локальных изменений


========================================================================================================================================================================================================


**Вопрос 1 (Тема: Многомерные деревья)**

Как меняется эффективность k-d деревьев при поиске ближайших соседей в пространствах с высокой размерностью?

A) Производительность не зависит от размерности пространства.

B) Эффективность снижается при увеличении размерности.

C) Они работают лучше в высокоразмерных пространствах.

D) Размерность не влияет на количество вычислений.

**Правильный ответ:** B) Эффективность снижается при увеличении размерности.

---

**Вопрос 2 (Тема: Фрактальные деревья)**

В чем основное преимущество фрактальных деревьев при работе с данными на диске?

A) Сокращают количество операций ввода-вывода, объединяя их.

B) Просты в реализации и не требуют балансировки.

C) Обеспечивают быстрый доступ к данным благодаря плоской структуре.

D) Экономят оперативную память за счет рекурсивности.

**Правильный ответ:** A) Сокращают количество операций ввода-вывода, объединяя их.

---

**Вопрос 3 (Тема: LSM-деревья)**

Как LSM-деревья достигают высокой скорости при записи данных?

A) Хранят данные в сбалансированном дереве в памяти.

B) Используют журнал транзакций для записей.

C) Записывают данные последовательно на диск и периодически объединяют уровни.

D) Применяют хеш-таблицы для распределения данных.

**Правильный ответ:** C) Записывают данные последовательно на диск и периодически объединяют уровни.

---

**Вопрос 4 (Тема: Сборки таблиц)**

Что означает термин "сборка таблиц" в контексте баз данных?

A) Разбиение таблицы на части для оптимизации запросов.

B) Объединение результатов нескольких запросов в одну таблицу.

C) Денормализация данных для ускорения вставки.

D) Метод соединения таблиц, оптимизированный для распределенных систем.

**Правильный ответ:** D) Метод соединения таблиц, оптимизированный для распределенных систем.

---

**Вопрос 5 (Тема: Деревья конфликта)**

В каком случае использование деревьев конфликта наименее целесообразно?

A) Управление версиями в системах контроля кода.

B) Разрешение конфликтов транзакций в распределенных базах данных.

C) Обработка коллизий в криптографических хеш-функциях.

D) Отслеживание изменений в совместных документах.

**Правильный ответ:** C) Обработка коллизий в криптографических хеш-функциях.

---

**Вопрос 6 (Тема: Сословные деревья)**

Для чего используются сословные деревья в информатике?

A) Моделирование социальных иерархий в искусственном интеллекте.

B) Организация прав доступа в операционных системах.

C) Управление потоками в сетевых приложениях.

D) Структурирование данных в файловых системах.

**Правильный ответ:** A) Моделирование социальных иерархий в искусственном интеллекте.

---

**Вопрос 7 (Тема: Деревья Евклида)**

Для какой задачи применяются деревья Евклида при работе с графами?

A) Поиск кратчайшего пути в графе.

B) Оптимизация маршрутизации в сетях.

C) Построение минимального остовного дерева на плоскости.

D) Разбиение графа на компоненты.

**Правильный ответ:** C) Построение минимального остовного дерева на плоскости.

---

**Вопрос 8 (Тема: Бинарные решающие диаграммы)**

Что существенно влияет на размер упорядоченной бинарной решающей диаграммы (OBDD) для булевой функции?

A) Количество переменных в функции.

B) Порядок расположения переменных в диаграмме.

C) Использование рекурсии при построении.

D) Наличие циклов между переменными.

**Правильный ответ:** B) Порядок расположения переменных в диаграмме.

---

**Вопрос 9 (Тема: Деревья префиксов)**

Чем патриция отличается от обычного префиксного дерева (trie) при хранении строк?

A) Хранит ключи только фиксированной длины.

B) Использует хеширование вместо символов.

C) Объединяет узлы с одним потомком для экономии памяти.

D) Не поддерживает поиск подстрок.

**Правильный ответ:** C) Объединяет узлы с одним потомком для экономии памяти.

---

**Вопрос 10 (Тема: Деревья паттернов)**

В каком случае эффективно использовать дерево паттернов?

A) При анализе временных рядов.

B) При сжатии данных адаптивными алгоритмами.

C) При поиске часто встречающихся наборов элементов в больших данных.

D) При построении синтаксических деревьев в компиляторах.

**Правильный ответ:** C) При поиске часто встречающихся наборов элементов в больших данных.


========================================================================================================================================================================================================


1. **Тема 151: Аффинные деревья**

Какую структуру данных используют в компьютерной графике для эффективного применения аффинных преобразований к объектам сцены, организованным иерархически?

A) Бинарное дерево поиска  
B) Граф сцены  
C) AVL-дерево  
D) B-дерево

**Правильный ответ:** B) Граф сцены

---

2. **Тема 152: Деревья суффиксов**

Для чего используются суффиксные деревья в алгоритмах работы со строками?

A) Для поиска самого частого символа  
B) Для быстрого поиска подстрок  
C) Для сжатия строк без потери данных  
D) Для сортировки символов в порядке Unicode

**Правильный ответ:** B) Для быстрого поиска подстрок

---

3. **Тема 153: Деревья Гомори**

Для решения какой задачи в теории графов применяют дерево Гомори?

A) Нахождение минимального остовного дерева  
B) Поиск циклов в графе  
C) Поиск кратчайших путей между всеми парами вершин  
D) Определение минимальных разрезов между парами вершин

**Правильный ответ:** D) Определение минимальных разрезов между парами вершин

---

4. **Тема 154: Деревья настроения**

Какая структура данных помогает анализировать тональность текста, моделируя зависимости между словами в предложениях?

A) Синтаксическое дерево  
B) Префиксное дерево (trie)  
C) Дерево решений  
D) Суффиксное дерево

**Правильный ответ:** A) Синтаксическое дерево

---

5. **Тема 155: Стеки вызовов**

Какая проблема может возникнуть при глубокой рекурсии из-за особенностей стека вызовов?

A) Утечка памяти  
B) Переполнение стека  
C) Переполнение буфера  
D) Двойное освобождение памяти

**Правильный ответ:** B) Переполнение стека

---

6. **Тема 156: Иерархические деревья**

Какой тип дерева лучше всего подходит для представления файловой системы, где каждое папка может содержать множество вложенных файлов и папок?

A) Бинарное дерево  
B) B-дерево  
C) N-арное дерево  
D) Красно-черное дерево

**Правильный ответ:** C) N-арное дерево

---

7. **Тема 157: Гамма-коды**

В каком случае имеет смысл использовать гамма-коды Элиаса?

A) Для сжатия больших файлов с разными данными  
B) Для кодирования небольших положительных чисел  
C) При работе с текстовыми файлами  
D) Для шифрования данных

**Правильный ответ:** B) Для кодирования небольших положительных чисел

---

8. **Тема 158: Деревья регистров**

Для чего компиляторы строят деревья регистров при оптимизации кода?

A) Чтобы упростить арифметические выражения  
B) Чтобы минимизировать количество используемых регистров  
C) Для организации циклов и ветвлений  
D) Для обработки исключений

**Правильный ответ:** B) Чтобы минимизировать количество используемых регистров

---

9. **Тема 159: Деревья доступа**

Какое самобалансирующееся дерево при каждом обращении к элементу перемещает его ближе к корню, оптимизируя последующие доступы?

A) AVL-дерево  
B) Splay-дерево  
C) Красно-черное дерево  
D) B+-дерево

**Правильный ответ:** B) Splay-дерево

---

10. **Тема 160: Деревья индексации**

Какую структуру данных чаще всего используют в базах данных для реализации индексов и эффективного доступа к большим объемам информации на дисках?

A) Двоичное дерево поиска  
B) R-дерево  
C) B-дерево  
D) Суффиксное дерево

**Правильный ответ:** C) B-дерево


========================================================================================================================================================================================================


**Вопрос по теме 161: Фильтры клеток**

Что верно для фильтров клеток при проверке принадлежности элемента множеству?

A) В них можно удалять элементы без появления ложных отрицаний.

B) Они гарантируют отсутствие ложноположительных результатов.

C) Они требуют больше памяти, чем обычные Блум-фильтры.

D) Используют криптографические хеш-функции для безопасности.

**Правильный ответ:** A) В них можно удалять элементы без появления ложных отрицаний.

---

**Вопрос по теме 162: Деревья бит**

Какую задачу решают деревья бит в обработке данных?

A) Быстрый поиск подстрок в тексте.

B) Подсчет количества единичных битов в диапазоне.

C) Эффективное хранение больших чисел с экономией памяти.

D) Сжатие мультимедийных файлов с потерями.

**Правильный ответ:** B) Подсчет количества единичных битов в диапазоне.

---

**Вопрос по теме 163: Деревья вероятности**

В какой области обычно применяются деревья вероятности?

A) Прогнозирование погоды на основе исторических данных.

B) Сжатие данных через частотный анализ символов.

C) Создание шифров для защиты информации.

D) Построение нейронных сетей в машинном обучении.

**Правильный ответ:** B) Сжатие данных через частотный анализ символов.

---

**Вопрос по теме 164: Гистограммы**

Как сократить объем данных гистограммы без значительной потери точности?

A) Увеличить количество бинов.

B) Использовать кумулятивную гистограмму.

C) Объединить соседние бины с низкой частотой.

D) Нормализовать данные перед построением.

**Правильный ответ:** C) Объединить соседние бины с низкой частотой.

---

**Вопрос по теме 165: Алгоритмы поиска ближайшего соседа**

Какой метод эффективен для поиска ближайших соседей в данных высокой размерности, избегая "проклятия размерности"?

A) Использовать k-d деревья.

B) Применить локально чувствительное хеширование (LSH).

C) Перебирать все точки последовательно.

D) Использовать R-деревья для индексирования.

**Правильный ответ:** B) Применить локально чувствительное хеширование (LSH).

---

**Вопрос по теме 166: Деревья разности**

Для чего используются деревья разности в алгоритмах?

A) Эффективное выполнение диапазонных обновлений в массиве.

B) Нахождение наибольшего общего делителя.

C) Поиск кратчайшего пути в графе.

D) Быстрая сортировка массивов.

**Правильный ответ:** A) Эффективное выполнение диапазонных обновлений в массиве.

---

**Вопрос по теме 167: Деревья суммы**

В чем преимущество деревьев суммы при работе с массивами?

A) Доступ к элементам за постоянное время O(1).

B) Вычисление суммы на отрезке за O(log n).

C) Экономия памяти при хранении данных.

D) Упрощение параллельной обработки данных.

**Правильный ответ:** B) Вычисление суммы на отрезке за O(log n).

---

**Вопрос по теме 168: D-деревья**

Какой особенностью отличаются D-деревья от других деревьев поиска?

A) Данные хранятся только в листьях.

B) Используют динамическую степень узлов для оптимизации.

C) Применяют двойное хеширование для распределения ключей.

D) Основываются на вейвлет-преобразовании данных.

**Правильный ответ:** B) Используют динамическую степень узлов для оптимизации.

---

**Вопрос по теме 169: Y-деревья**

В чем особенность Y-деревьев при хранении данных?

A) Сочетают свойства B-деревьев и k-d деревьев для многомерных данных.

B) Используют разбиение узлов по координатам X, Y и Z.

C) Хранят вероятности для поиска наиболее вероятного пути.

D) Самобалансируются путем вращений, как AVL-деревья.

**Правильный ответ:** A) Сочетают свойства B-деревьев и k-d деревьев для многомерных данных.

---

**Вопрос по теме 170: H-деревья**

Где часто применяются H-деревья и с какой целью?

A) В базах данных для оптимизации запросов.

B) В проектировании микросхем для разводки сигналов.

C) В графике для создания реалистичных деревьев.

D) В криптографии для надежных хеш-функций.

**Правильный ответ:** B) В проектировании микросхем для разводки сигналов.


========================================================================================================================================================================================================


1. **Тема 171: G-деревья**

При работе с алгоритмами поиска кратчайшего пути в больших дорожных сетях, для чего используются G-деревья?

A) Оптимизация использования памяти при параллельной обработке графов

B) Иерархическое разбиение графа и индексирование для ускорения запросов кратчайших путей

C) Представление географических данных в трехмерном пространстве

D) Сжатие графа с сохранением точности измерения расстояний между узлами

**Правильный ответ:**  
B) Иерархическое разбиение графа и индексирование для ускорения запросов кратчайших путей

---

2. **Тема 172: Z-деревья**

Какова основная задача Z-деревьев при работе с многомерными данными?

A) Улучшение сжатия данных в базах данных

B) Эффективное пространственное индексирование с использованием Z-порядка для быстрого поиска диапазонов

C) Оптимизация балансировки бинарных деревьев поиска

D) Предотвращение коллизий в хеш-таблицах с многомерными ключами

**Правильный ответ:**  
B) Эффективное пространственное индексирование с использованием Z-порядка для быстрого поиска диапазонов

---

3. **Тема 173: W-деревья**

Что позволяет добиться использование вейвлет-деревьев (W-деревьев) при обработке последовательностей?

A) Сжимать данные без потери информации и быстро их восстанавливать

B) Выполнять быстрые запросы по диапазонам и частоте элементов в последовательности

C) Улучшать производительность операций вставки и удаления в деревьях поиска

D) Снижать сложность сортировки больших объемов данных

**Правильный ответ:**  
B) Выполнять быстрые запросы по диапазонам и частоте элементов в последовательности

---

4. **Тема 174: Динамические массивы**

Какова амортизированная сложность добавления элемента в конец динамического массива, который при переполнении удваивает свой размер?

A) O(1)

B) O(log n)

C) O(n)

D) O(n log n)

**Правильный ответ:**  
A) O(1)

---

5. **Тема 175: Таблицы разреженности**

Для какой задачи оптимально использовать таблицы разреженности (Sparse Table) при обработке данных?

A) Быстро обновлять элементы на отрезке массива

B) Находить минимум или максимум на отрезке в статическом массиве за O(1) после предварительной обработки

C) Эффективно сжимать данные с большим количеством нулей

D) Организовывать динамическую структуру данных с поддержкой вставки и удаления

**Правильный ответ:**  
B) Находить минимум или максимум на отрезке в статическом массиве за O(1) после предварительной обработки

---

6. **Тема 176: Деревья частот**

В алгоритме кодирования Хаффмана строится дерево частот. Какова главная цель этого дерева?

A) Обеспечить равномерное распределение символов в коде

B) Минимизировать среднюю длину кодовых слов на основе частоты символов

C) Ускорить процесс декодирования данных

D) Сгруппировать символы по их бинарному представлению

**Правильный ответ:**  
B) Минимизировать среднюю длину кодовых слов на основе частоты символов

---

7. **Тема 177: Дисциплины памяти**

Какая дисциплина управления памятью реализует принцип "первым пришёл — первым вышел" (FIFO) при освобождении памяти?

A) Стековая (Stack)

B) Куча (Heap)

C) Очередь (Queue)

D) Сегментная (Segment)

**Правильный ответ:**  
C) Очередь (Queue)

---

8. **Тема 178: Очереди с приоритетами**

Какой способ позволяет эффективно реализовать очередь с приоритетами с операциями вставки и извлечения максимума за O(log n)?

A) Несортированный связный список

B) Двоичная куча (Binary Heap)

C) Сортированный массив

D) Хеш-таблица для приоритетов

**Правильный ответ:**  
B) Двоичная куча (Binary Heap)

---

9. **Тема 179: Кучи биномные**

Какова сложность поиска минимального элемента в биномной куче и почему?

A) O(1), потому что минимальный элемент всегда в корне

B) O(log n), так как нужно просмотреть все корни деревьев

C) O(n), так как требуется обход всей кучи

D) O(log log n), благодаря структуре биномных деревьев

**Правильный ответ:**  
B) O(log n), так как нужно просмотреть все корни деревьев

---

10. **Тема 180: Кучи дноуправляемые**

Какова временная сложность построения кучи методом "снизу вверх" (bottom-up) для массива из n элементов?

A) O(n)

B) O(n log n)

C) O(log n)

D) O(n²)

**Правильный ответ:**  
A) O(n)


========================================================================================================================================================================================================


1. **Тема 181: Адресные деревья**

   Какая структура данных используется в операционных системах для преобразования виртуальных адресов в физические?

   A) Хеш-таблица  
   B) Дерево сегментов  
   C) Многоуровневая страничная таблица  
   D) Бинарное дерево поиска  

   **Правильный ответ:** C) Многоуровневая страничная таблица

---

2. **Тема 182: Ассоциативные массивы**

   В чем заключается особенность ассоциативных массивов в языках программирования?

   A) Доступ к элементам по числовым индексам, начиная с нуля  
   B) Доступ к значениям по произвольным ключам различных типов  
   C) Хранение данных в отсортированном виде для быстрого поиска  
   D) Использование только строковых ключей фиксированной длины  

   **Правильный ответ:** B) Доступ к значениям по произвольным ключам различных типов

---

3. **Тема 183: Пространственные индексы**

   Какой тип пространственного индекса наиболее эффективен для поиска объектов в заданном радиусе на плоскости?

   A) KD-дерево  
   B) B+-дерево  
   C) R*-дерево  
   D) Суффиксное дерево  

   **Правильный ответ:** C) R*-дерево

---

4. **Тема 184: Инвертированные индексы**

   Как можно уменьшить размер инвертированного индекса в поисковой системе без существенной потери скорости поиска?

   A) Использовать связные списки для хранения позиций слов  
   B) Применить сжатие разниц между позициями (gap encoding)  
   C) Дублировать данные для ускорения доступа  
   D) Хранить данные в текстовом файле  

   **Правильный ответ:** B) Применить сжатие разниц между позициями (gap encoding)

---

5. **Тема 185: Построение индексов**

   Какой метод построения индексов подходит для больших потоков данных и обеспечивает быструю вставку и чтение?

   A) Одноэтапное построение статического индекса  
   B) Создание индекса в памяти с последующей записью на диск  
   C) Использование LSM-деревьев (Log-Structured Merge Trees)  
   D) Перестроение B-дерева при каждой вставке  

   **Правильный ответ:** C) Использование LSM-деревьев (Log-Structured Merge Trees)

---

6. **Тема 186: Списки свободных блоков**

   Какой метод управления свободной памятью помогает избежать фрагментации?

   A) Первый подходящий блок (First Fit)  
   B) Лучший подходящий блок (Best Fit)  
   C) Сегрегированные списки по размеру блоков  
   D) Циклический список свободных блоков  

   **Правильный ответ:** C) Сегрегированные списки по размеру блоков

---

7. **Тема 187: Аренные аллокаторы**

   В чем преимущество использования аренного аллокатора памяти?

   A) Точный контроль времени жизни объектов  
   B) Быстрое освобождение памяти одним действием  
   C) Оптимизация распределения памяти между потоками  
   D) Автоматическое уменьшение фрагментации  

   **Правильный ответ:** B) Быстрое освобождение памяти одним действием

---

8. **Тема 188: Стековые аллокаторы**

   Когда удобно использовать стековый аллокатор памяти?

   A) Для больших объемов памяти с неизвестным временем жизни  
   B) При реализации глубоких рекурсий  
   C) Когда требуется быстрое выделение и освобождение в порядке LIFO  
   D) Для совместного использования памяти между процессами  

   **Правильный ответ:** C) Когда требуется быстрое выделение и освобождение в порядке LIFO

---

9. **Тема 189: Оконные буферы**

   Зачем используется скользящий оконный буфер при обработке потоковых данных?

   A) Чтобы сохранить все входные данные  
   B) Для хранения недавних данных и постоянного вычисления  
   C) Для буферизации вывода перед отправкой  
   D) Для распределения данных между потоками  

   **Правильный ответ:** B) Для хранения недавних данных и постоянного вычисления

---

10. **Тема 190: LRU-кэши**

    Как реализовать LRU-кэш с операциями за O(1) время?

    A) Использовать массив с линейным поиском  
    B) Объединить хеш-таблицу и двусвязный список  
    C) Применить кучу с перестройкой при каждом обращении  
    D) Использовать циклический буфер с приоритетами  

    **Правильный ответ:** B) Объединить хеш-таблицу и двусвязный список


========================================================================================================================================================================================================


**Вопрос 1 (Тема 191 - Графовые базы данных):**

В графовых базах данных важно обеспечить высокую производительность сложных запросов. Какой фактор сильнее всего влияет на скорость выполнения запросов, содержащих сложные обходы по графу?

A) Унифицированная схема для всех типов вершин и ребер.

B) Оптимизация кэша процессора для графовых операций.

C) Размещение связанных вершин и ребер рядом в памяти для улучшения локальности данных.

D) Использование SQL-языков запросов для совместимости с реляционными базами данных.

**Правильный ответ:** C

---

**Вопрос 2 (Тема 192 - Хранение больших графов):**

Какой метод наиболее эффективно экономит память при хранении разреженных графов с миллиардами вершин и ребер?

A) Использование матрицы смежности.

B) Применение сжатого списка смежности с индексированием.

C) Хранение графа в виде отдельных файлов с описанием вершин.

D) Распределение графа по нескольким серверам для распределенного хранения.

**Правильный ответ:** B

---

**Вопрос 3 (Тема 193 - Алгоритмы обработки графов):**

Какой алгоритм наиболее эффективно обнаруживает циклы в ориентированном графе при минимальных затратах ресурсов?

A) Алгоритм Крускала.

B) Поиск в глубину с пометками посещенных вершин.

C) Алгоритм Дейкстры.

D) Алгоритм Флойда–Уоршелла.

**Правильный ответ:** B

---

**Вопрос 4 (Тема 194 - Алгоритмы планаризации графов):**

Какой подход позволяет представить непланарный граф на плоскости без пересечений ребер, минимально изменяя его структуру?

A) Удаление минимального числа ребер для достижения планарности.

B) Добавление вершин в точки пересечения ребер (введение псевдоузлов).

C) Разбиение графа на планарные подграфы с последующим объединением.

D) Преобразование графа в его двойственный граф.

**Правильный ответ:** B

---

**Вопрос 5 (Тема 195 - Алгоритмы разрезов):**

Какой алгоритм гарантирует нахождение минимального разреза в неориентированном графе за полиномиальное время?

A) Алгоритм Гомори–Ху.

B) Алгоритм Краскала.

C) Рандомизированный алгоритм Кергера.

D) Алгоритм Прима.

**Правильный ответ:** A

---

**Вопрос 6 (Тема 196 - Деревья доминаторов):**

Какой алгоритм наиболее эффективно вычисляет доминаторное дерево для графа потока управления в программах?

A) Алгоритм Ленцера и Тарьяна.

B) Алгоритм Дейкстры.

C) Топологическая сортировка.

D) Алгоритм Беллмана–Форда.

**Правильный ответ:** A

---

**Вопрос 7 (Тема 197 - Сетевая маршрутизация):**

Какой протокол маршрутизации использует алгоритм Дейкстры для определения оптимальных маршрутов внутри автономной системы?

A) OSPF (Open Shortest Path First).

B) RIP (Routing Information Protocol).

C) BGP (Border Gateway Protocol).

D) IS-IS (Intermediate System to Intermediate System).

**Правильный ответ:** A

---

**Вопрос 8 (Тема 198 - Поиск в глубину с отсечением):**

Какое преимущество имеет итеративное углубление по сравнению с обычным поиском в глубину с ограничением глубины?

A) Требует меньше памяти за счет меньшей глубины рекурсии.

B) Находит более короткие пути в глубоких графах.

C) Сочетает преимущества поиска в глубину и ширину, улучшая поиск оптимальных решений.

D) Избегает повторных посещений узлов с помощью хеширования.

**Правильный ответ:** C

---

**Вопрос 9 (Тема 199 - Поиск в ширину с ограничением):**

Как повлияет увеличение максимальной глубины в поиске в ширину с ограничением на работу алгоритма в плотных графах?

A) Сократит время выполнения за счет уменьшения количества узлов на уровне.

B) Увеличит использование памяти и времени из-за экспоненциального роста числа узлов.

C) Уменьшит число найденных решений, пропуская глубокие узлы.

D) Сделает поиск эффективнее, так как важные узлы находятся глубже.

**Правильный ответ:** B

---

**Вопрос 10 (Тема 200 - A* алгоритм):**

Какое свойство эвристической функции в алгоритме A* гарантирует нахождение оптимального пути и сокращает число проверяемых узлов?

A) Эвристика не должна превышать реальную стоимость до цели (допустимость).

B) Эвристика должна точно равняться реальной стоимости до цели.

C) Эвристика может превышать реальную стоимость для ускорения алгоритма.

D) Эвристика должна быть независимой от пространства поиска.

**Правильный ответ:** A


========================================================================================================================================================================================================


**Вопрос 1 (Тема: Бесконечные структуры данных)**

В функциональных языках программирования с ленивыми вычислениями как используются бесконечные списки?

A) Все элементы бесконечного списка вычисляются и хранятся в памяти сразу.

B) Элементы бесконечного списка вычисляются по мере необходимости, что позволяет работать с бесконечными последовательностями.

C) Бесконечные списки применяются только для моделирования циклических структур данных.

D) Перед использованием нужно вычислить все элементы бесконечного списка.

**Правильный ответ:** B)

---

**Вопрос 2 (Тема: Структуры данных для потоков)**

Какой из следующих алгоритмов наиболее подходит для нахождения медианы в бесконечном потоке данных при ограниченной памяти?

A) Метод случайной выборки (Reservoir Sampling)

B) Алгоритм Count-Min Sketch

C) Алгоритм Фагина для поиска Top-k элементов

D) Использование двух куч: минимальной и максимальной (min-heap и max-heap)

**Правильный ответ:** D)

---

**Вопрос 3 (Тема: Очереди сообщений)**

Какой механизм позволяет гарантировать, что сообщение в очереди сообщений будет обработано только один раз, даже если возникают сбои?

A) Маршрутизация сообщений между очередями

B) Удаление дубликатов на стороне получателя

C) Подтверждение получения сообщения (acknowledgement) с помощью транзакций

D) Отложенная отправка сообщений

**Правильный ответ:** C)

---

**Вопрос 4 (Тема: Транзакционные структуры данных)**

Какой подход позволяет реализовать изолированные транзакции в структурах данных без использования блокировок, повышая масштабируемость в многопоточных системах?

A) Применение общей блокировки на всю структуру данных

B) Использование многоверсионного управления параллелизмом (MVCC) с версионированием данных

C) Оптимистическое выполнение с откатом в случае конфликтов

D) Использование транзакций на уровне аппаратуры процессора

**Правильный ответ:** B)

---

**Вопрос 5 (Тема: Локальные структуры данных)**

Как локальность ссылок влияет на производительность структур данных в современных компьютерах?

A) Улучшает производительность за счёт лучшего предсказания ветвлений

B) Ускоряет доступ к данным благодаря эффективному использованию кэша памяти

C) Повышает безопасность данных за счёт изоляции процессов

D) Облегчает распределение задач между различными узлами сети

**Правильный ответ:** B)

---

**Вопрос 6 (Тема: Распределенные структуры данных)**

В распределенных системах для чего используется алгоритм "двухфазного коммита" (Two-Phase Commit) при работе со структурами данных?

A) Чтобы обеспечить согласованность данных между узлами при выполнении транзакций

B) Для ускорения запросов через параллельную обработку

C) Для уменьшения сетевых задержек при передаче данных

D) Для равномерного распределения нагрузки между серверами

**Правильный ответ:** A)

---

**Вопрос 7 (Тема: Облачные структуры данных)**

Что обеспечивает высокую доступность и отказоустойчивость данных в облачных структурах без потери согласованности?

A) Хранение всех данных на одном центральном сервере

B) Репликация данных с автоматическим переключением при сбое (фейловер)

C) Разделение данных на части (шардинг) без дублирования

D) Асинхронная синхронизация данных между узлами

**Правильный ответ:** B)

---

**Вопрос 8 (Тема: Кэширование данных)**

Какой алгоритм кэширования сочетает в себе преимущества LRU и LFU, адаптируясь к изменяющимся паттернам доступа для повышения эффективности кэша?

A) FIFO (First-In, First-Out)

B) MRU (Most Recently Used)

C) ARC (Adaptive Replacement Cache)

D) SCR (Second Chance Replacement)

**Правильный ответ:** C)

---

**Вопрос 9 (Тема: Полнотекстовые индексы)**

Какой подход позволяет полнотекстовому индексу эффективно обрабатывать поисковые запросы с учётом разных форм слова (например, падежей или времен)?

A) Хранение слов в базовой форме с использованием стемминга или лемматизации

B) Индексирование каждой возможной формы слова без изменений

C) Применение деревьев, основанных на последовательностях символов

D) Использование фонетических алгоритмов для сопоставления схожих по звучанию слов

**Правильный ответ:** A)

---

**Вопрос 10 (Тема: BM-деревья)**

Чем BM-дерево (Buffered B-tree) отличается от классического B-дерева, делая его более эффективным при большом количестве вставок и удалений в базах данных на дисках?

A) Использует буферы в узлах для пакетной обработки операций

B) Уплотняет данные в листьях для увеличения плотности записи

C) Применяет хеширование в узлах для быстрого доступа

D) Автоматически изменяет порядок дерева в зависимости от нагрузки

**Правильный ответ:** A)

---


========================================================================================================================================================================================================


**211. Многомерные хеш-таблицы**

**Вопрос:**

Какой метод хеширования лучше всего сохраняет близость данных при отображении многомерных ключей на одномерное пространство хеш-таблицы?

**Варианты ответов:**

A) Криптографическое хеширование  
B) Косинусное преобразование  
C) Z-порядок (Z-ordering)  
D) Универсальное хеширование  

**Ответ:**

C) Z-порядок (Z-ordering)

---

**212. Персистентные структуры данных**

**Вопрос:**

В персистентных структурах данных как метод "копирование при записи" (copy-on-write) помогает экономить память?

**Варианты ответов:**

A) Улучшает производительность при одновременных изменениях данных  
B) Позволяет совместно использовать неизмененные части структуры  
C) Упрощает удаление старых версий во время сборки мусора  
D) Предотвращает доступ к устаревшим версиям данных  

**Ответ:**

B) Позволяет совместно использовать неизмененные части структуры

---

**213. Зипперы**

**Вопрос:**

Как зипперы в функциональном программировании позволяют эффективно изменять неизменяемые деревья?

**Варианты ответов:**

A) Изменяют узлы напрямую с помощью изменяемых ссылок  
B) Хранят путь от корня к текущему узлу для быстрого доступа и изменения  
C) Копируют все дерево при каждом изменении  
D) Используют отложенные вычисления для поздних изменений  

**Ответ:**

B) Хранят путь от корня к текущему узлу для быстрого доступа и изменения

---

**214. Линейные хеш-таблицы**

**Вопрос:**

Как линейное хеширование расширяет хеш-таблицу без перестройки всей структуры?

**Варианты ответов:**

A) Удваивает размер таблицы и перераспределяет все элементы  
B) Последовательно разделяет только переполненные бакеты  
C) Применяет открытую адресацию с увеличением индексов  
D) Добавляет новые бакеты в фиксированные позиции независимо от заполнения  

**Ответ:**

B) Последовательно разделяет только переполненные бакеты

---

**215. Расширяемые хеш-таблицы**

**Вопрос:**

В расширяемом хешировании какую структуру используют для управления ростом таблицы, и как это влияет на поиск?

**Варианты ответов:**

A) Директорию, позволяющую увеличивать глубину хеширования без перераспределения данных  
B) Балансируемое дерево для логарифмического времени доступа  
C) Кольцевой буфер для циклического обхода элементов  
D) Связный список для добавления новых элементов в конец  

**Ответ:**

A) Директорию, позволяющую увеличивать глубину хеширования без перераспределения данных

---

**216. Кэши прямого отображения**

**Вопрос:**

Какое основное ограничение кэша с прямым отображением может снизить его эффективность?

**Варианты ответов:**

A) Сложность реализации из-за необходимости ассоциативного поиска  
B) Большой объем памяти для хранения тегов  
C) Частые конфликты из-за жесткой привязки адресов к линиям кэша  
D) Медленный доступ из-за дополнительного уровня абстракции  

**Ответ:**

C) Частые конфликты из-за жесткой привязки адресов к линиям кэша

---

**217. Директ-мэппинг**

**Вопрос:**

В кэше с прямым отображением как определяется место хранения данных и как это влияет на производительность?

**Варианты ответов:**

A) Место выбирается случайно, уменьшая конфликты  
B) Используется хеш-функция для равномерного распределения  
C) Адреса памяти напрямую соответствуют линиям кэша, что может увеличить промахи  
D) Данные хранятся последовательно для предсказания доступа  

**Ответ:**

C) Адреса памяти напрямую соответствуют линиям кэша, что может увеличить промахи

---

**218. Наборно-ассоциативные кэши**

**Вопрос:**

Почему в наборно-ассоциативном кэше внутри одного набора есть несколько линий, и какое это дает преимущество?

**Варианты ответов:**

A) Увеличивает скорость за счет одновременного чтения  
B) Снижает конфликты, позволяя хранить несколько блоков с одинаковыми индексами  
C) Уменьшает энергопотребление, активируя нужные линии  
D) Обеспечивает безопасность через изоляцию процессов  

**Ответ:**

B) Снижает конфликты, позволяя хранить несколько блоков с одинаковыми индексами

---

**219. Полностью ассоциативные кэши**

**Вопрос:**

В полностью ассоциативном кэше как происходит поиск данных, и как это сказывается на времени доступа?

**Варианты ответов:**

A) Последовательный перебор всех линий, что замедляет поиск  
B) Хеширование адресов для быстрого доступа  
C) Параллельное сравнение адреса со всеми тегами, требующее сложной аппаратуры  
D) Использование дерева поиска для логарифмического доступа  

**Ответ:**

C) Параллельное сравнение адреса со всеми тегами, требующее сложной аппаратуры

---

**220. Таблицы страниц**

**Вопрос:**

Как многоуровневая структура таблицы страниц помогает экономить память в системах виртуальной памяти?

**Варианты ответов:**

A) Загружает в память только нужные части таблицы по мере обращения  
B) Ускоряет трансляцию адресов, сокращая обращения к памяти  
C) Обеспечивает изоляцию процессов благодаря отдельным таблицам  
D) Увеличивает виртуальное пространство без изменений физической памяти  

**Ответ:**

A) Загружает в память только нужные части таблицы по мере обращения


========================================================================================================================================================================================================


1. **Тема 221: Инвертированные таблицы страниц**

   _Вопрос:_ В чём основное преимущество инвертированной таблицы страниц по сравнению с традиционной таблицей в системах с большим объёмом оперативной памяти?

   **A)** Требует меньше памяти для хранения таблицы страниц.

   **B)** Ускоряет доступ к страницам в памяти.

   **C)** Уменьшает фрагментацию виртуальной памяти.

   **D)** Повышает безопасность процессов.

   **Правильный ответ:** A

2. **Тема 222: Буфер трансляции адресов (TLB)**

   _Вопрос:_ Какую роль выполняет буфер трансляции адресов (TLB) в работе процессора с памятью?

   **A)** Кэширует соответствия виртуальных и физических адресов.

   **B)** Сжимает данные для экономии памяти.

   **C)** Предсказывает ветвления в программе.

   **D)** Загружает страницы из диска в память.

   **Правильный ответ:** A

3. **Тема 223: Ассоциативные кэши**

   _Вопрос:_ Чем полностью ассоциативный кэш отличается от кэша с прямым отображением?

   **A)** Размером кэша.

   **B)** Количеством циклов доступа к данным.

   **C)** Гибкостью размещения данных в кэше.

   **D)** Типом используемой памяти.

   **Правильный ответ:** C

4. **Тема 224: Структуры данных для виртуальной памяти**

   _Вопрос:_ Какое преимущество дают многоуровневые таблицы страниц в операционных системах?

   **A)** Ускоряют доступ к памяти за счёт параллельной обработки.

   **B)** Сокращают объём памяти, необходимый для таблиц страниц.

   **C)** Повышают безопасность путём изоляции процессов.

   **D)** Упрощают управление виртуальной памятью.

   **Правильный ответ:** B

5. **Тема 225: Структуры данных для файловых систем**

   _Вопрос:_ Какая структура данных позволяет эффективнее всего управлять свободным пространством в файловой системе?

   **A)** Список свободных блоков.

   **B)** B+-дерево.

   **C)** Журнал транзакций.

   **D)** Инвертированный индекс.

   **Правильный ответ:** A

6. **Тема 226: B*-деревья**

   _Вопрос:_ Чем B*-деревья отличаются от обычных B-деревьев в работе с внешней памятью?

   **A)** Имеют дополнительный уровень для быстрого поиска.

   **B)** Перераспределяют ключи между узлами перед разделением.

   **C)** Хранят хеш-значения ключей для ускорения доступа.

   **D)** Листовые узлы связаны между собой двусвязно.

   **Правильный ответ:** B

7. **Тема 227: H-деревья**

   _Вопрос:_ Почему H-деревья используются при разработке микросхем с высокой плотностью компонентов?

   **A)** Минимизируют задержки сигналов благодаря равным длинам путей.

   **B)** Обеспечивают гибкую маршрутизацию сигналов.

   **C)** Снижают потребление энергии схемой.

   **D)** Упрощают процесс производства микросхем.

   **Правильный ответ:** A

8. **Тема 228: Цифровые индексы**

   _Вопрос:_ Как цифровые индексы ускоряют поиск данных по ключу?

   **A)** Преобразуют ключи в числовой формат для сортировки.

   **B)** Разбивают ключи на биты и сравнивают их последовательно.

   **C)** Используют хеш-функции для прямого доступа.

   **D)** Применяют параллельные алгоритмы поиска.

   **Правильный ответ:** B

9. **Тема 229: Крит-битные деревья**

   _Вопрос:_ Как крит-битные деревья эффективно работают со строковыми ключами?

   **A)** Сравнивают ключи побитно, начиная с первого различающегося бита.

   **B)** Хранят хеши строк вместо самих строк.

   **C)** Используют вращения узлов для балансировки.

   **D)** Сжимают повторяющиеся подстроки в узлах.

   **Правильный ответ:** A

10. **Тема 230: Обходы графов с запоминанием (мемоизацией)**

    _Вопрос:_ Зачем при обходе графов с циклами используют запоминание (мемоизацию) результатов?

    **A)** Чтобы избежать бесконечного зацикливания.

    **B)** Для ускорения работы за счёт повторного использования вычислений.

    **C)** Чтобы построить остовное дерево графа.

    **D** Для нахождения кратчайших путей между вершинами.

    **Правильный ответ:** B


========================================================================================================================================================================================================


Вопрос 1:

Какой способ хранения разреженных данных позволяет ускорить обучение моделей машинного обучения на больших высокоразмерных наборах?

A) Плотные матрицы
B) Разреженные матрицы в формате CSR
C) Связные списки
D) Хеш-таблицы

**Правильный ответ:** B) Разреженные матрицы в формате CSR

---

Вопрос 2:

Какой метод при построении деревьев решений вводит случайность в выбор признаков на каждом узле, чтобы уменьшить переобучение?

A) Критерий информации Шеннона
B) Метод уменьшения ошибки классификации
C) Метод случайных подпространств
D) Метод случайных поворотов

**Правильный ответ:** C) Метод случайных подпространств

---

Вопрос 3:

В алгоритме случайного леса как формируют обучающую выборку для каждого дерева, чтобы повысить общую производительность модели?

A) Используют весь исходный набор данных
B) Выбирают случайные подмножества признаков для каждого узла
C) Генерируют бутстреп-выборки с возвращением
D) Применяют градиентный спуск для настройки параметров

**Правильный ответ:** C) Генерируют бутстреп-выборки с возвращением

---

Вопрос 4:

В градиентном бустинге какой параметр особенно важен для контроля сложности модели и предотвращения переобучения?

A) Число деревьев в ансамбле
B) Максимальная глубина деревьев
C) Скорость обучения (learning rate)
D) Минимальный размер листа

**Правильный ответ:** C) Скорость обучения (learning rate)

---

Вопрос 5:

Какой метод ускоряет поиск **k** ближайших соседей в данных высокой размерности?

A) **k-d** деревья
B) Барьерные деревья
C) Хеширование, чувствительное к локальности (LSH)
D) Балансированные бинарные деревья поиска

**Правильный ответ:** C) Хеширование, чувствительное к локальности (LSH)

---

Вопрос 6:

В методе опорных векторов (SVM) при большом объёме данных как эффективно вычислять скалярные произведения между векторами признаков?

A) Использовать ядровой трюк с разреженными данными
B) Применять преобразование Хафа
C) Использовать деревья решений
D) Применять первоначальную форму SVM

**Правильный ответ:** A) Использовать ядровой трюк с разреженными данными

---

Вопрос 7:

При использовании хеширования, чувствительного к локальности (LSH), какие хеш-функции применяют для эффективного поиска похожих объектов в евклидовом пространстве?

A) Проекции на случайные гиперплоскости
B) Минхеширование
C) Комбинацию универсальных хеш-функций
D) Модульное хеширование

**Правильный ответ:** A) Проекции на случайные гиперплоскости

---

Вопрос 8:

Какой алгоритм кластеризации способен обнаруживать кластеры произвольной формы, устойчив к выбросам и не требует заранее задавать число кластеров?

A) **K**-средних
B) Иерархическая кластеризация
C) DBSCAN
D) Спектральная кластеризация

**Правильный ответ:** C) DBSCAN

---

Вопрос 9:

Какое утверждение о методе **K**-средних неверно?

A) Стремится минимизировать сумму квадратов расстояний внутри кластеров
B) Результат зависит от начального положения центроидов
C) Всегда находит глобальный минимум функции стоимости
D) Предполагает сферические кластеры одинакового размера

**Правильный ответ:** C) Всегда находит глобальный минимум функции стоимости

---

Вопрос 10:

Какой алгоритм позволяет находить частые наборы элементов без генерации всех возможных кандидатных наборов?

A) Apriori
B) FP-Growth
C) Eclat
D) AIS

**Правильный ответ:** B) FP-Growth


========================================================================================================================================================================================================


1. **Тема 241: Частые наборы**

Алгоритм Apriori при поиске частых наборов генерирует очень много кандидатов, что замедляет работу на больших данных. Какой метод позволяет эффективно находить частые наборы без создания множества кандидатов?

A) Алгоритм K-means  
B) Метод FP-Growth  
C) Установка минимальной поддержки в 100%  
D) Алгоритм Дейкстры  

**Правильный ответ:**  
B) Метод FP-Growth

---

2. **Тема 242: FP-деревья**

В методе FP-Growth используется структура FP-дерева для поиска частых наборов. На каком принципе основано FP-дерево, позволяющее эффективно сжать информацию о транзакциях?

A) Хранение только уникальных транзакций  
B) Объединение общих префиксов транзакций  
C) Использование хеш-таблицы для быстрого доступа  
D) Разделение базы данных на части  

**Правильный ответ:**  
B) Объединение общих префиксов транзакций

---

3. **Тема 243: Структуры данных в NLP**

Для задач автодополнения и исправления опечаток нужно быстро искать слова по префиксам. Какую структуру данных лучше всего использовать для этого?

A) Бинарное дерево поиска  
B) Префиксное дерево (Trie)  
C) Хеш-таблица  
D) Граф  

**Правильный ответ:**  
B) Префиксное дерево (Trie)

---

4. **Тема 244: N-граммы**

При использовании N-грамм с большим N в языковых моделях часто возникает проблема разреженности данных. Какой метод сглаживания помогает скорректировать вероятности редких или незамеченных N-грамм?

A) Лемматизация  
B) Сглаживание Кнезера-Нея  
C) Стемминг  
D) Бинаризация  

**Правильный ответ:**  
B) Сглаживание Кнезера-Нея

---

5. **Тема 245: Марковские цепи**

Скрытые марковские модели предполагают, что будущее состояние зависит только от текущего. В каком случае это предположение нарушается, что может привести к неточным результатам?

A) Моделирование движения частиц  
B) Анализ ДНК с долгосрочными зависимостями  
C) Прогноз погоды на основе текущих данных  
D) Моделирование игры в рулетку  

**Правильный ответ:**  
B) Анализ ДНК с долгосрочными зависимостями

---

6. **Тема 246: Деревья зависимостей**

При синтаксическом разборе предложений используются деревья зависимостей для отображения связей между словами. Какой алгоритм парсинга обеспечивает линейную скорость работы и подходит для больших текстовых корпусов?

A) Алгоритм Эрли  
B) Алгоритм CYK  
C) Переходный парсинг  
D) Алгоритм Витерби  

**Правильный ответ:**  
C) Переходный парсинг

---

7. **Тема 247: Структуры данных для изображений**

Для эффективного хранения двумерных изображений с неоднородными областями используется структура, которая адаптивно делит пространство. Какая это структура данных?

A) Квадродерево  
B) Граф сцены  
C) Матрица пикселей  
D) Суффиксное дерево  

**Правильный ответ:**  
A) Квадродерево

---

8. **Тема 248: Канторово множество**

Канторовское множество образуется путем бесконечного удаления средних третьих частей отрезка. Какова его фрактальная (Хаусдорфова) размерность?

A) 0,5  
B) ln(2) / ln(3)  
C) 1  
D) 2  

**Правильный ответ:**  
B) ln(2) / ln(3)

---

9. **Тема 249: Графы**

При работе с большими разреженными графами важно эффективно хранить ребра. Какая структура данных для этого наиболее подходит?

A) Матрица смежности  
B) Список смежности  
C) Матрица инцидентности  
D) Множество ребер  

**Правильный ответ:**  
B) Список смежности

---

10. **Тема 250: Метрики сходства**

Чтобы кластеризовать текстовые документы, нужно измерить степень их сходства. Какой метод лучше всего учитывает частоту и значимость слов?

A) Расстояние Хэмминга  
B) Косинусное сходство с использованием TF-IDF  
C) Евклидово расстояние между частотами букв  
D) Коэффициент корреляции Пирсона  

**Правильный ответ:**  
B) Косинусное сходство с использованием TF-IDF


========================================================================================================================================================================================================


**Вопрос 1 (Тема 251: Алгоритмы рекомендаций)**

Когда новый пользователь только что зарегистрировался и у него ещё нет истории взаимодействий, какой метод рекомендаций лучше всего поможет предложить ему подходящие товары или контент?

a) Коллаборативная фильтрация на основе пользовательских данных

b) Контентная фильтрация

c) Коллаборативная фильтрация с использованием моделей

d) Рекомендации на основе социальных связей

**Ответ:** b) Контентная фильтрация

---

**Вопрос 2 (Тема 252: Структуры данных для информационного поиска)**

Как называется инвертированный индекс, который хранит не только термы документов, но и позиции этих термов внутри документов, что позволяет эффективно искать фразы?

a) Компрессированный инвертированный индекс

b) Позиционный инвертированный индекс

c) Инвертированный индекс с префиксными деревьями

d) Индекс с информацией о близости термов

**Ответ:** b) Позиционный инвертированный индекс

---

**Вопрос 3 (Тема 253: Обфускация данных)**

Какой метод обфускации кода изменяет его структуру таким образом, чтобы сохранить работоспособность программы, но затруднить анализ, вводя запутанные пути выполнения и лишние зависимости?

a) Символическая обфускация

b) Обфускация контрольного потока

c) Семантическая обфускация

d) Шифрование данных в коде

**Ответ:** b) Обфускация контрольного потока

---

**Вопрос 4 (Тема 254: Структуры данных для криптографии)**

Какая структура данных используется в криптографических протоколах для эффективного доступа к множеству ключей, при этом знание одного ключа не раскрывает информацию о других?

a) Хеш-таблица с цепочками

b) Идеальное хеширование

c) Префиксное дерево (Trie)

d) Односвязный список

**Ответ:** c) Префиксное дерево (Trie)

---

**Вопрос 5 (Тема 255: Алгоритмы шифрования)**

Какой алгоритм шифрования основывается на сложности дискретного логарифмирования над эллиптическими кривыми и используется для создания компактных цифровых подписей?

a) RSA

b) Алгоритм Диффи-Хеллмана

c) Алгоритм ЭлГамаля

d) ECDSA (Эллиптический DSA)

**Ответ:** d) ECDSA (Эллиптический DSA)

---

**Вопрос 6 (Тема 256: Деревья Меркла)**

Где применяются деревья Меркла для проверки целостности больших объемов данных, сокращая количество передаваемых хешей при валидации?

a) Протоколы передачи файлов по сети

b) Реляционные базы данных

c) Распространение обновлений программ

d) Файловые системы с поддержкой снапшотов

**Ответ:** a) Протоколы передачи файлов по сети

---

**Вопрос 7 (Тема 257: Структуры блокчейна)**

Как называется механизм в блокчейне, который позволяет согласовывать последовательность транзакций без центрального управляющего органа, обеспечивая неизменяемость данных?

a) Смарт-контракты

b) Децентрализованный консенсус

c) Протокол шардирования

d) Алгоритм хеширования SHA-256

**Ответ:** b) Децентрализованный консенсус

---

**Вопрос 8 (Тема 258: Хэш-графы)**

В чем главное отличие хэш-графа от традиционного блокчейна в контексте распределенных реестров?

a) Использование последовательных блоков вместо графов

b) Отсутствие необходимости верификации транзакций доверенными узлами

c) Поддержка асинхронной византийской отказоустойчивости (aBFT)

d) Применение квантовых методов шифрования

**Ответ:** c) Поддержка асинхронной византийской отказоустойчивости (aBFT)

---

**Вопрос 9 (Тема 259: Алгоритмы консенсуса)**

Какой алгоритм консенсуса выбирает случайного лидера для каждого раунда, что помогает достигать соглашения о порядке транзакций и повышает масштабируемость и безопасность сети?

a) Proof of Work (PoW)

b) Practical Byzantine Fault Tolerance (PBFT)

c) Raft

d) Algorand

**Ответ:** d) Algorand

---

**Вопрос 10 (Тема 260: Трансформационные структуры данных)**

Как называется структура данных, которая позволяет эффективно выполнять вставку и удаление элементов в любом месте последовательности за логарифмическое время?

a) Веревка (Rope)

b) Сбалансированное дерево поиска

c) Дек

d) Стек

**Ответ:** a) Веревка (Rope)


========================================================================================================================================================================================================


**Вопрос 1 (Реляционные модели):**

В реляционной модели данных, в чем основное отличие между третьей нормальной формой (3НФ) и нормальной формой Бойса-Кодда (НФБК)?

A) 3НФ допускает некоторые функциональные зависимости, которые НФБК исключает.

B) В НФБК каждый детерминант должен быть кандидатом в ключи, а в 3НФ это не обязательно.

C) НФБК позволяет избыточность данных, а 3НФ стремится ее минимизировать.

D) 3НФ устраняет частичные зависимости, а НФБК не обращает на них внимания.

**Правильный ответ:** B) В НФБК каждый детерминант должен быть кандидатом в ключи, а в 3НФ это не обязательно.

---

**Вопрос 2 (Нереляционные модели):**

Какой тип нереляционной базы данных лучше всего подходит для хранения и обработки сильно связанных иерархических данных с возможностью выполнять сложные запросы по связям между элементами?

A) Документо-ориентированная база данных

B) Графовая база данных

C) Колонкоориентированная база данных

D) База данных типа "ключ-значение"

**Правильный ответ:** B) Графовая база данных

---

**Вопрос 3 (Гибридные модели):**

В гибридных базах данных, объединяющих реляционные и нереляционные модели, какое преимущество дают полиморфные связи при моделировании данных?

A) Они ускоряют транзакции за счет оптимизации индексов.

B) Позволяют связывать разные типы сущностей без изменения структуры базы данных.

C) Обеспечивают лучшую нормализацию данных, устраняя дублирование.

D) Улучшают масштабируемость при горизонтальном разделении данных.

**Правильный ответ:** B) Позволяют связывать разные типы сущностей без изменения структуры базы данных.

---

**Вопрос 4 (Структуры данных для аудио):**

Какой алгоритм преобразует звуковой сигнал из временной области в частотную для дальнейшего анализа?

A) Быстрое преобразование Фурье (БПФ)

B) Алгоритм Краскала

C) Суффиксный массив

D) Кодирование Хаффмана

**Правильный ответ:** A) Быстрое преобразование Фурье (БПФ)

---

**Вопрос 5 (Волновые пакеты):**

В каком случае дискретное вейвлет-преобразование предпочтительнее быстрого преобразования Фурье при сжатии данных?

A) Когда нужно анализировать только частоты сигнала.

B) Когда требуется анализ как по времени, так и по частоте.

C) Если сигнал содержит только низкие частоты.

D) Когда необходима без потерь компрессия данных.

**Правильный ответ:** B) Когда требуется анализ как по времени, так и по частоте.

---

**Вопрос 6 (Сплайн-интерполяция):**

Какой тип сплайнов следует использовать для сглаживания функции, обеспечивая непрерывность самой функции и ее первых двух производных?

A) Линейные сплайны

B) Квадратичные сплайны

C) Кубические сплайны

D) Сплайны нулевого порядка

**Правильный ответ:** C) Кубические сплайны

---

**Вопрос 7 (Индексирование временных рядов):**

Какой метод индексирования временных рядов преобразует данные в символы, снижая их размерность для эффективного сравнения длинных последовательностей?

A) Динамическое временное растяжение (DTW)

B) Индексирование с помощью R-деревьев

C) Символьное агрегатное аппроксимирование (SAX)

D) Хеширование с открытой адресацией

**Правильный ответ:** C) Символьное агрегатное аппроксимирование (SAX)

---

**Вопрос 8 (R-деревья с временными метками):**

Какое основное преимущество использования TPR-деревьев (Time-Parameterized R-trees) при работе с движущимися объектами в базах данных?

A) Точное прогнозирование будущего положения объектов.

B) Индексирование объектов с учетом их скорости и направления движения.

C) Снижение объема памяти за счет сжатия данных.

D) Ускорение поиска статичных объектов.

**Правильный ответ:** B) Индексирование объектов с учетом их скорости и направления движения.

---

**Вопрос 9 (Структуры данных для геоданных):**

Какая структура данных эффективнее всего хранит и быстро ищет географические данные, которые неравномерно распределены и сгруппированы в отдельных областях?

A) Регулярная сетка (Grid)

B) K-D дерево

C) R*-дерево

D) Географическая хеш-таблица

**Правильный ответ:** C) R*-дерево

---

**Вопрос 10 (Пространственные индексы):**

Какой из следующих пространственных индексов наиболее эффективен для поиска ближайших соседей в трехмерном пространстве?

A) Z-кривая порядок (Z-order curve)

B) Октадерево (Octree)

C) B+-дерево

D) Двумерный хеш-индекс

**Правильный ответ:** B) Октадерево (Octree)


========================================================================================================================================================================================================


**Вопрос 1 (Геохеширование)**

Какой метод используется для кодирования географических координат в геохешировании?

A) Деление пространства на области по принципу Z-порядка

B) Кодирование координат с помощью функции MD5

C) Применение алгоритма сжатия Хаффмана

D) Создание фрактальных геометрических узоров

**Правильный ответ:** A) Деление пространства на области по принципу Z-порядка

---

**Вопрос 2 (Структуры данных для IoT)**

Что наиболее важно учесть при разработке структур данных для устройств Интернета вещей (IoT) с ограниченными ресурсами?

A) Поддержку многопоточности

B) Минимальное использование памяти и энергии

C) Максимальную скорость доступа к диску

D) Включение сложных алгоритмов машинного обучения

**Правильный ответ:** B) Минимальное использование памяти и энергии

---

**Вопрос 3 (Потоковые структуры данных)**

Какая структура данных эффективна для обработки больших потоков данных в реальном времени с ограниченной памятью, позволяя получать приближенные результаты?

A) Count-Min Sketch

B) B-дерево

C) Суффиксное дерево

D) AVL-дерево

**Правильный ответ:** A) Count-Min Sketch

---

**Вопрос 4 (Временные структуры данных)**

Какая структура данных позволяет эффективно хранить и запрашивать данные с учетом их временных версий и интервалов?

A) R-дерево

B) Временное B-дерево (Time-indexed B-tree)

C) Хеш-таблица с временными метками

D) Куча Фибоначчи

**Правильный ответ:** B) Временное B-дерево

---

**Вопрос 5 (Алгоритмы сжатия данных)**

Какой алгоритм сжатия сначала преобразует данные для увеличения последовательностей одинаковых символов, а затем сжимает их?

A) Алгоритм Хаффмана

B) LZ77

C) Преобразование Барроуза-Уилера (BWT)

D) Кодирование длин серий (RLE)

**Правильный ответ:** C) Преобразование Барроуза-Уилера (BWT)

---

**Вопрос 6 (Алгоритмы кодирования)**

Какой алгоритм кодирования использует дробные числа для представления сообщений и обеспечивает высокую степень сжатия при неравномерных вероятностях символов?

A) Кодирование Хаффмана

B) Аритметическое кодирование

C) Кодирование Лемпеля-Зива (LZ78)

D) Кодирование Голомба

**Правильный ответ:** B) Аритметическое кодирование

---

**Вопрос 7 (Алгоритмы декодирования)**

Какой алгоритм используется для итеративного декодирования кодов с исправлением ошибок, применяемый в турбо-кодах и LDPC-кодах?

A) Алгоритм Витерби

B) Алгоритм Беллмана-Форда

C) Алгоритм сумм-продукт (Sum-Product Algorithm)

D) Алгоритм Дейкстры

**Правильный ответ:** C) Алгоритм сумм-продукт

---

**Вопрос 8 (Сжатие без потерь)**

Какой формат сжатия без потерь использует предсказание значений пикселей для уменьшения избыточности изображения перед энтропийным кодированием?

A) JPEG

B) PNG

C) GIF

D) TIFF

**Правильный ответ:** B) PNG

---

**Вопрос 9 (Сжатие с потерями)**

Какой формат аудиосжатия с потерями использует психоакустическую модель для удаления звуков, незаметных для человеческого уха?

A) FLAC

B) ALAC

C) MP3

D) WAV

**Правильный ответ:** C) MP3

---

**Вопрос 10 (Параллельные структуры данных)**

Какая структура данных обеспечивает корректный многопоточный доступ без использования блокировок?

A) Безблокирующий стек (Lock-Free Stack)

B) Связный список с мьютексами

C) Бинарное дерево с общей блокировкой

D) Очередь с условными переменными

**Правильный ответ:** A) Безблокирующий стек


========================================================================================================================================================================================================


281. Что означает понятие **«конечная согласованность»** (eventual consistency) в распределённых системах данных?

A) Данные на всех узлах всегда полностью синхронизированы.  
B) Если нет новых изменений, то со временем все узлы отразят последнее обновление данных.  
C) Согласованность данных гарантируется только при стабильной сетевой связи.  
D) Система обеспечивает атомарные транзакции между всеми узлами.

**Ответ:** B

---

282. Какой метод используется в базах знаний для представления неточных или неполных данных?

A) Логика первого порядка  
B) Нечёткая логика  
C) Реляционная алгебра  
D) Конечные автоматы

**Ответ:** B

---

283. Какова основная цель использования **онтологий** в информатике?

A) Хранение больших объёмов данных в виде иерархий  
B) Формальное описание понятий и их отношений для совместимости систем  
C) Ускорение алгоритмов машинного обучения  
D) Создание эффективных структур данных для сортировки элементов

**Ответ:** B

---

284. Чем **семантические сети** отличаются от обычных графов?

A) В них отсутствуют циклы  
B) Связи имеют направление и обозначают тип отношений между узлами  
C) Они всегда представлены в виде матриц смежности  
D) Все связи одинаковы и не имеют различий

**Ответ:** B

---

285. Какая особенность **не** характерна для деревьев аргументации?

A) Иерархическое представление аргументов и контраргументов  
B) Моделирование логических рассуждений и обсуждений  
C) Обеспечение мгновенного доступа O(1) к любому элементу  
D) Наличие поддерживающих и опровергающих связей между аргументами

**Ответ:** C

---

286. В чём главное отличие между **дискуссионными деревьями** и **деревьями аргументации** при моделировании диалогов?

A) Первые используются в обработке естественного языка, вторые — в логических вычислениях  
B) Дискуссионные деревья не имеют иерархии, а деревья аргументации структурированы  
C) Дискуссионные деревья фокусируются на последовательности сообщений, а деревья аргументации — на логических связях  
D) Между ними нет отличий; это два названия одного и того же понятия

**Ответ:** C

---

287. Какой алгоритм чаще всего используется в **коллаборативной фильтрации** для рекомендаций на основе сходства пользователей?

A) Метод k-средних (k-means)  
B) Латентное размещение Дирихле (LDA)  
C) Алгоритм k ближайших соседей (k-NN)  
D) Генетические алгоритмы

**Ответ:** C

---

288. Какая структура данных наиболее эффективна для поиска общих друзей между пользователями в большой социальной сети?

A) Хеш-таблица  
B) Матрица смежности  
C) Списки смежности с индексированием  
D) Бинарное дерево поиска

**Ответ:** C

---

289. Какое свойство характеризует феномен **«малого мира»** в социальных графах?

A) Большинство узлов имеют низкую степень связности  
B) Между любыми двумя узлами существует короткий путь через небольшое число связей  
C) Степень связности узлов равномерно распределена по графу  
D) Граф имеет строгую иерархическую структуру

**Ответ:** B

---

290. Какой алгоритм наиболее эффективно находит **минимальное остовное дерево** в взвешенном графе?

A) Алгоритм Дейкстры  
B) Алгоритм Прима  
C) Алгоритм Флойда–Уоршелла  
D) Алгоритм Кнута–Морриса–Пратта

**Ответ:** B


========================================================================================================================================================================================================


1. **Тема 291: Модели масштабируемости**

Законы Амдала и Густафсона описывают ограничения ускорения программ при добавлении новых процессоров. В чём основное различие между этими законами?

A) Закон Амдала предполагает фиксированный объём работы, а закон Густафсона — изменяющийся при увеличении ресурсов.

B) Закон Густафсона учитывает задержки в системе, а закон Амдала — нет.

C) Закон Амдала применим только к линейным задачам, а закон Густафсона — к нелинейным.

D) Оба закона описывают одинаковые ограничения без существенных различий.

**Правильный ответ:**

A) Закон Амдала предполагает фиксированный объём работы, а закон Густафсона — изменяющийся при увеличении ресурсов.

---

2. **Тема 292: Журналы транзакций**

В системах баз данных журнал транзакций используется для восстановления после сбоев. Какой метод журнализации сокращает задержки во время работы, но может увеличить время восстановления?

A) Незамедлительная запись

B) Отложенная запись

C) Теневая копия

D) Предварительная запись журнала

**Правильный ответ:**

B) Отложенная запись

---

3. **Тема 293: Снапшоты**

В распределённых системах важно создать согласованный снимок состояния без остановки процессов. Какой алгоритм позволяет сделать это без использования глобальных часов?

A) Логические часы Лэмпорта

B) Алгоритм Чанди–Лэмпорта для снапшотов

C) Алгоритм выбора лидера в кольце

D) Алгоритм обедающих философов

**Правильный ответ:**

B) Алгоритм Чанди–Лэмпорта для снапшотов

---

4. **Тема 294: Кольцевые буферы**

При реализации кольцевого буфера в многопоточной среде, какой способ обеспечивает быстрый и безопасный доступ без блокировок?

A) Использование атомарных операций для управления указателями

B) Применение мьютексов для синхронизации

C) Копирование данных при каждом доступе

D) Ограничение доступа к буферу одним потоком

**Правильный ответ:**

A) Использование атомарных операций для управления указателями

---

5. **Тема 295: Конвейеры данных**

Как в конвейерной обработке данных эффективно сбалансировать нагрузку между этапами, чтобы повысить производительность?

A) Жёстко распределить задачи между этапами независимо от загрузки

B) Динамически распределять задачи с учётом текущей нагрузки

C) Увеличить буферы между этапами для накопления задач

D) Обрабатывать задачи последовательно без конвейера

**Правильный ответ:**

B) Динамически распределять задачи с учётом текущей нагрузки

---

6. **Тема 296: Event Sourcing**

В подходе Event Sourcing система хранит состояние как последовательность событий. Какой недостаток этого метода может стать критичным при большом объёме данных?

A) Сложно восстановить текущее состояние из длинной цепочки событий

B) Нельзя воспроизвести историю изменений системы

C) Нет поддержки масштабирования на несколько серверов

D) Увеличиваются затраты на хранение из-за дублирования

**Правильный ответ:**

A) Сложно восстановить текущее состояние из длинной цепочки событий

---

7. **Тема 297: Архитектуры CQRS**

В архитектуре CQRS разделяют модели для чтения и записи данных. Какое преимущество даёт это разделение?

A) Упрощение кода за счёт объединения логики

B) Возможность оптимизировать каждую модель под свои задачи

C) Снижение потребности в аппаратных ресурсах

D) Облегчение тестирования благодаря единой модели

**Правильный ответ:**

B) Возможность оптимизировать каждую модель под свои задачи

---

8. **Тема 298: Очереди заданий**

Как в системах с очередями заданий обнаруживать и обрабатывать задачи, которые не завершились из-за сбоя исполнителя?

A) Ручной мониторинг и вмешательство оператора

B) Использование приоритетов при планировании

C) Подтверждение выполнения задач и повторная отправка при отсутствии подтверждения

D) Ограничение времени выполнения задач системой

**Правильный ответ:**

C) Подтверждение выполнения задач и повторная отправка при отсутствии подтверждения

---

9. **Тема 299: Планировщики задач**

Какой метод в планировщиках задач обеспечивает выполнение периодических задач даже после перезапуска системы?

A) Хранить расписание и состояние задач в постоянном хранилище

B) Использовать асинхронные вызовы без сохранения состояния

C) Хранить состояние задач в оперативной памяти

D) Увеличить частоту выполнения задач

**Правильный ответ:**

A) Хранить расписание и состояние задач в постоянном хранилище

---

10. **Тема 300: Кэширование обратного вызова**

Как клиенты могут получать обновлённые данные без постоянных запросов к серверу?

A) Кэшировать данные на клиенте с фиксированным временем жизни

B) Сервер отправляет обновления клиентам через push-уведомления

C) Клиент регулярно опрашивает сервер на наличие изменений

D) Не использовать кэш и запрашивать данные каждый раз

**Правильный ответ:**

B) Сервер отправляет обновления клиентам через push-уведомления